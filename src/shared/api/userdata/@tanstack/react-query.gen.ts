// This file is auto-generated by @hey-api/openapi-ts

import { queryOptions, type UseMutationOptions } from '@tanstack/react-query';

import { client } from '../client.gen';
import { createCategoryCategoryPost, createParamCategoryCategoryIdParamPost, createSourceSourcePost, deleteCategoryCategoryIdDelete, deleteParamCategoryCategoryIdParamIdDelete, deleteSourceSourceIdDelete, getCategoriesCategoryGet, getCategoryCategoryIdGet, getParamCategoryCategoryIdParamIdGet, getParamsCategoryCategoryIdParamGet, getSourceSourceIdGet, getSourcesSourceGet, getUserInfoUserIdGet, getUsersInfoUserGet, type Options, patchCategoryCategoryIdPatch, patchParamCategoryCategoryIdParamIdPatch, patchSourceSourceIdPatch, updateUserUserIdPost } from '../sdk.gen';
import type { CreateCategoryCategoryPostData, CreateCategoryCategoryPostError, CreateCategoryCategoryPostResponse, CreateParamCategoryCategoryIdParamPostData, CreateParamCategoryCategoryIdParamPostError, CreateParamCategoryCategoryIdParamPostResponse, CreateSourceSourcePostData, CreateSourceSourcePostError, CreateSourceSourcePostResponse, DeleteCategoryCategoryIdDeleteData, DeleteCategoryCategoryIdDeleteError, DeleteCategoryCategoryIdDeleteResponse, DeleteParamCategoryCategoryIdParamIdDeleteData, DeleteParamCategoryCategoryIdParamIdDeleteError, DeleteParamCategoryCategoryIdParamIdDeleteResponse, DeleteSourceSourceIdDeleteData, DeleteSourceSourceIdDeleteError, DeleteSourceSourceIdDeleteResponse, GetCategoriesCategoryGetData, GetCategoryCategoryIdGetData, GetParamCategoryCategoryIdParamIdGetData, GetParamsCategoryCategoryIdParamGetData, GetSourceSourceIdGetData, GetSourcesSourceGetData, GetUserInfoUserIdGetData, GetUsersInfoUserGetData, PatchCategoryCategoryIdPatchData, PatchCategoryCategoryIdPatchError, PatchCategoryCategoryIdPatchResponse, PatchParamCategoryCategoryIdParamIdPatchData, PatchParamCategoryCategoryIdParamIdPatchError, PatchParamCategoryCategoryIdParamIdPatchResponse, PatchSourceSourceIdPatchData, PatchSourceSourceIdPatchError, PatchSourceSourceIdPatchResponse, UpdateUserUserIdPostData, UpdateUserUserIdPostError, UpdateUserUserIdPostResponse } from '../types.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? client).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const getSourcesSourceGetQueryKey = (options?: Options<GetSourcesSourceGetData>) => createQueryKey('getSourcesSourceGet', options);

/**
 * Get Sources
 *
 * Получить все источники данных
 */
export const getSourcesSourceGetOptions = (options?: Options<GetSourcesSourceGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSourcesSourceGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSourcesSourceGetQueryKey(options)
    });
};

/**
 * Create Source
 *
 * Создать источник данных
 *
 * Scopes: `["userdata.source.create"]`
 */
export const createSourceSourcePostMutation = (options?: Partial<Options<CreateSourceSourcePostData>>): UseMutationOptions<CreateSourceSourcePostResponse, CreateSourceSourcePostError, Options<CreateSourceSourcePostData>> => {
    const mutationOptions: UseMutationOptions<CreateSourceSourcePostResponse, CreateSourceSourcePostError, Options<CreateSourceSourcePostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createSourceSourcePost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Source
 *
 * Удалить источник данных
 *
 * Scopes: `["userdata.source.delete"]`
 */
export const deleteSourceSourceIdDeleteMutation = (options?: Partial<Options<DeleteSourceSourceIdDeleteData>>): UseMutationOptions<DeleteSourceSourceIdDeleteResponse, DeleteSourceSourceIdDeleteError, Options<DeleteSourceSourceIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteSourceSourceIdDeleteResponse, DeleteSourceSourceIdDeleteError, Options<DeleteSourceSourceIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteSourceSourceIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getSourceSourceIdGetQueryKey = (options: Options<GetSourceSourceIdGetData>) => createQueryKey('getSourceSourceIdGet', options);

/**
 * Get Source
 *
 * Получить источник данных
 */
export const getSourceSourceIdGetOptions = (options: Options<GetSourceSourceIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSourceSourceIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSourceSourceIdGetQueryKey(options)
    });
};

/**
 * Patch Source
 *
 * Обновить источник данных
 *
 * Scopes: `["userdata.source.update"]`
 */
export const patchSourceSourceIdPatchMutation = (options?: Partial<Options<PatchSourceSourceIdPatchData>>): UseMutationOptions<PatchSourceSourceIdPatchResponse, PatchSourceSourceIdPatchError, Options<PatchSourceSourceIdPatchData>> => {
    const mutationOptions: UseMutationOptions<PatchSourceSourceIdPatchResponse, PatchSourceSourceIdPatchError, Options<PatchSourceSourceIdPatchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchSourceSourceIdPatch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCategoriesCategoryGetQueryKey = (options?: Options<GetCategoriesCategoryGetData>) => createQueryKey('getCategoriesCategoryGet', options);

/**
 * Get Categories
 *
 * Получить все категории
 */
export const getCategoriesCategoryGetOptions = (options?: Options<GetCategoriesCategoryGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCategoriesCategoryGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCategoriesCategoryGetQueryKey(options)
    });
};

/**
 * Create Category
 *
 * Создать категорию пользовательских данных. Получить категорию можно будет со скоупами, имена которых в category_inp.scopes
 * Ручка обновит документацию
 *
 * Scopes: `["userdata.category.create"]`
 */
export const createCategoryCategoryPostMutation = (options?: Partial<Options<CreateCategoryCategoryPostData>>): UseMutationOptions<CreateCategoryCategoryPostResponse, CreateCategoryCategoryPostError, Options<CreateCategoryCategoryPostData>> => {
    const mutationOptions: UseMutationOptions<CreateCategoryCategoryPostResponse, CreateCategoryCategoryPostError, Options<CreateCategoryCategoryPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createCategoryCategoryPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Category
 *
 * Удалить категорию
 *
 * Scopes: `["userdata.category.delete"]`
 */
export const deleteCategoryCategoryIdDeleteMutation = (options?: Partial<Options<DeleteCategoryCategoryIdDeleteData>>): UseMutationOptions<DeleteCategoryCategoryIdDeleteResponse, DeleteCategoryCategoryIdDeleteError, Options<DeleteCategoryCategoryIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteCategoryCategoryIdDeleteResponse, DeleteCategoryCategoryIdDeleteError, Options<DeleteCategoryCategoryIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCategoryCategoryIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCategoryCategoryIdGetQueryKey = (options: Options<GetCategoryCategoryIdGetData>) => createQueryKey('getCategoryCategoryIdGet', options);

/**
 * Get Category
 *
 * Получить категорию
 */
export const getCategoryCategoryIdGetOptions = (options: Options<GetCategoryCategoryIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCategoryCategoryIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCategoryCategoryIdGetQueryKey(options)
    });
};

/**
 * Patch Category
 *
 * Обновить категорию
 *
 * Scopes: `["userdata.category.update"]`
 */
export const patchCategoryCategoryIdPatchMutation = (options?: Partial<Options<PatchCategoryCategoryIdPatchData>>): UseMutationOptions<PatchCategoryCategoryIdPatchResponse, PatchCategoryCategoryIdPatchError, Options<PatchCategoryCategoryIdPatchData>> => {
    const mutationOptions: UseMutationOptions<PatchCategoryCategoryIdPatchResponse, PatchCategoryCategoryIdPatchError, Options<PatchCategoryCategoryIdPatchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchCategoryCategoryIdPatch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getParamsCategoryCategoryIdParamGetQueryKey = (options: Options<GetParamsCategoryCategoryIdParamGetData>) => createQueryKey('getParamsCategoryCategoryIdParamGet', options);

/**
 * Get Params
 *
 * Получить все параметры категории
 */
export const getParamsCategoryCategoryIdParamGetOptions = (options: Options<GetParamsCategoryCategoryIdParamGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getParamsCategoryCategoryIdParamGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getParamsCategoryCategoryIdParamGetQueryKey(options)
    });
};

/**
 * Create Param
 *
 * Создать поле внутри категории. Ответ на пользовательские данные будет такой {..., category: {...,param: '', ...}}
 *
 * Scopes: `["userdata.param.create"]`
 */
export const createParamCategoryCategoryIdParamPostMutation = (options?: Partial<Options<CreateParamCategoryCategoryIdParamPostData>>): UseMutationOptions<CreateParamCategoryCategoryIdParamPostResponse, CreateParamCategoryCategoryIdParamPostError, Options<CreateParamCategoryCategoryIdParamPostData>> => {
    const mutationOptions: UseMutationOptions<CreateParamCategoryCategoryIdParamPostResponse, CreateParamCategoryCategoryIdParamPostError, Options<CreateParamCategoryCategoryIdParamPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createParamCategoryCategoryIdParamPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Param
 *
 * Удалить параметр внутри категории
 *
 * Scopes: `["userdata.param.delete"]`
 */
export const deleteParamCategoryCategoryIdParamIdDeleteMutation = (options?: Partial<Options<DeleteParamCategoryCategoryIdParamIdDeleteData>>): UseMutationOptions<DeleteParamCategoryCategoryIdParamIdDeleteResponse, DeleteParamCategoryCategoryIdParamIdDeleteError, Options<DeleteParamCategoryCategoryIdParamIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteParamCategoryCategoryIdParamIdDeleteResponse, DeleteParamCategoryCategoryIdParamIdDeleteError, Options<DeleteParamCategoryCategoryIdParamIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteParamCategoryCategoryIdParamIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getParamCategoryCategoryIdParamIdGetQueryKey = (options: Options<GetParamCategoryCategoryIdParamIdGetData>) => createQueryKey('getParamCategoryCategoryIdParamIdGet', options);

/**
 * Get Param
 *
 * Получить параметр по айди
 */
export const getParamCategoryCategoryIdParamIdGetOptions = (options: Options<GetParamCategoryCategoryIdParamIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getParamCategoryCategoryIdParamIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getParamCategoryCategoryIdParamIdGetQueryKey(options)
    });
};

/**
 * Patch Param
 *
 * Обновить параметр внутри категории
 *
 * Scopes: `["userdata.param.update"]`
 */
export const patchParamCategoryCategoryIdParamIdPatchMutation = (options?: Partial<Options<PatchParamCategoryCategoryIdParamIdPatchData>>): UseMutationOptions<PatchParamCategoryCategoryIdParamIdPatchResponse, PatchParamCategoryCategoryIdParamIdPatchError, Options<PatchParamCategoryCategoryIdParamIdPatchData>> => {
    const mutationOptions: UseMutationOptions<PatchParamCategoryCategoryIdParamIdPatchResponse, PatchParamCategoryCategoryIdParamIdPatchError, Options<PatchParamCategoryCategoryIdParamIdPatchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchParamCategoryCategoryIdParamIdPatch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUserInfoUserIdGetQueryKey = (options: Options<GetUserInfoUserIdGetData>) => createQueryKey('getUserInfoUserIdGet', options);

/**
 * Get User Info
 *
 * Получить информацию о пользователе
 */
export const getUserInfoUserIdGetOptions = (options: Options<GetUserInfoUserIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserInfoUserIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserInfoUserIdGetQueryKey(options)
    });
};

/**
 * Update User
 *
 * Обновить информацию о пользователе.
 * Объект - пользователь, информацию которого обновляют
 * Субъект - пользователь, который обновляет - источник
 *
 * Если не указать параметр внутри категории, то ничего не обновится, если указать что-то,
 * то либо создастся новая запись(в случае, если она отсутствовала у данного источника), либо отредактируется
 * старая. Если в значении параметра указан None, то соответствующая информациия удаляется из данного источника
 *
 * Обновлять через эту ручку можно только от имени источников admin и user.
 *
 * Чтобы обновить от имени админиа, надо иметь скоуп `userdata.info.admin`
 * Чтобы обновить неизменяемую информацию надо обладать скоупом `userdata.info.update`
 * Для обновления своей информации(источник `user`) не нужны скоупы на обновление соответствующих категорий
 * Для обновления чужой информации от имени админа(источник `admin`)
 * нужны скоупы на обновление всех указанных в теле запроса категорий пользовательских данных данных
 */
export const updateUserUserIdPostMutation = (options?: Partial<Options<UpdateUserUserIdPostData>>): UseMutationOptions<UpdateUserUserIdPostResponse, UpdateUserUserIdPostError, Options<UpdateUserUserIdPostData>> => {
    const mutationOptions: UseMutationOptions<UpdateUserUserIdPostResponse, UpdateUserUserIdPostError, Options<UpdateUserUserIdPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateUserUserIdPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUsersInfoUserGetQueryKey = (options: Options<GetUsersInfoUserGetData>) => createQueryKey('getUsersInfoUserGet', options);

/**
 * Get Users Info
 *
 * Получить информацию о пользователях.
 * :param users: список id юзеров, про которых нужно вернуть информацию
 * :param categories: список id категорий, параметры которых нужно вернуть
 * :return: список данных о пользователях и данных категориях
 */
export const getUsersInfoUserGetOptions = (options: Options<GetUsersInfoUserGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUsersInfoUserGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUsersInfoUserGetQueryKey(options)
    });
};

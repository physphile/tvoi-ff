// This file is auto-generated by @hey-api/openapi-ts

import { type InfiniteData, infiniteQueryOptions, queryOptions, type UseMutationOptions } from '@tanstack/react-query';

import { client } from '../client.gen';
import { createCommentCommentPost, createLecturerLecturerPost, deleteCommentCommentUuidDelete, deleteLecturerLecturerIdDelete, getCommentCommentUuidGet, getCommentsCommentGet, getLecturerLecturerIdGet, getLecturersLecturerGet, importCommentsCommentImportPost, likeCommentCommentUuidReactionPut, type Options, reviewCommentCommentUuidReviewPatch, updateCommentCommentUuidPatch, updateLecturerLecturerIdPatch, updateLecturerRatingLecturerImportRatingPatch } from '../sdk.gen';
import type { CreateCommentCommentPostData, CreateCommentCommentPostError, CreateCommentCommentPostResponse, CreateLecturerLecturerPostData, CreateLecturerLecturerPostError, CreateLecturerLecturerPostResponse, DeleteCommentCommentUuidDeleteData, DeleteCommentCommentUuidDeleteError, DeleteCommentCommentUuidDeleteResponse, DeleteLecturerLecturerIdDeleteData, DeleteLecturerLecturerIdDeleteError, DeleteLecturerLecturerIdDeleteResponse, GetCommentCommentUuidGetData, GetCommentsCommentGetData, GetCommentsCommentGetError, GetCommentsCommentGetResponse, GetLecturerLecturerIdGetData, GetLecturersLecturerGetData, GetLecturersLecturerGetError, GetLecturersLecturerGetResponse, ImportCommentsCommentImportPostData, ImportCommentsCommentImportPostError, ImportCommentsCommentImportPostResponse, LikeCommentCommentUuidReactionPutData, LikeCommentCommentUuidReactionPutError, LikeCommentCommentUuidReactionPutResponse, ReviewCommentCommentUuidReviewPatchData, ReviewCommentCommentUuidReviewPatchError, ReviewCommentCommentUuidReviewPatchResponse, UpdateCommentCommentUuidPatchData, UpdateCommentCommentUuidPatchError, UpdateCommentCommentUuidPatchResponse, UpdateLecturerLecturerIdPatchData, UpdateLecturerLecturerIdPatchError, UpdateLecturerLecturerIdPatchResponse, UpdateLecturerRatingLecturerImportRatingPatchData, UpdateLecturerRatingLecturerImportRatingPatchError, UpdateLecturerRatingLecturerImportRatingPatchResponse } from '../types.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? client).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const getLecturersLecturerGetQueryKey = (options?: Options<GetLecturersLecturerGetData>) => createQueryKey('getLecturersLecturerGet', options);

/**
 * Get Lecturers
 *
 * `limit` - максимальное количество возвращаемых преподавателей
 *
 * `offset` - нижняя граница получения преподавателей, т.е. если по дефолту первым возвращается преподаватель с условным номером N, то при наличии ненулевого offset будет возвращаться преподаватель с номером N + offset
 *
 * `order_by` - возможные значения `"mark_weighted", "mark_kindness", "mark_freebie", "mark_clarity", "mark_general", "last_name"`.
 * Если передано `'last_name'` - возвращается список преподавателей отсортированных по алфавиту по фамилиям
 * Если передано `'mark_...'` - возвращается список преподавателей отсортированных по конкретной оценке
 * Если передано просто так (или с '+' в начале параметра), то сортирует по возрастанию
 * С '-' в начале -- по убыванию.
 *
 * *Пример запросов с этим параметром*:
 * - `...?order_by=-mark_kindness`
 * - `...?order_by=mark_freebie`
 * - `...?order_by=+mark_freebie` (эквивалентно 2ому пункту)
 *
 * `info` - возможные значения `'comments'`.
 * Если передано `'comments'`, то возвращаются одобренные комментарии к преподавателю.
 *
 * `subject`
 * Если передано `subject` - возвращает всех преподавателей, для которых переданное значение совпадает с одним из их предметов преподавания.
 * Также возвращает всех преподавателей, у которых есть комментарий с совпадающим с данным subject.
 *
 * `name`
 * Поле для ФИО. Если передано `name` - возвращает всех преподователей, для которых нашлись совпадения с переданной строкой
 *
 * `mark`
 * Поле для оценки. Если передано, то возвращает только тех преподавателей, для которых средняя общая оценка ('general_mark')
 * больше, чем переданный 'mark'.
 */
export const getLecturersLecturerGetOptions = (options?: Options<GetLecturersLecturerGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLecturersLecturerGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLecturersLecturerGetQueryKey(options)
    });
};

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = {
        ...queryKey[0]
    };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const getLecturersLecturerGetInfiniteQueryKey = (options?: Options<GetLecturersLecturerGetData>): QueryKey<Options<GetLecturersLecturerGetData>> => createQueryKey('getLecturersLecturerGet', options, true);

/**
 * Get Lecturers
 *
 * `limit` - максимальное количество возвращаемых преподавателей
 *
 * `offset` - нижняя граница получения преподавателей, т.е. если по дефолту первым возвращается преподаватель с условным номером N, то при наличии ненулевого offset будет возвращаться преподаватель с номером N + offset
 *
 * `order_by` - возможные значения `"mark_weighted", "mark_kindness", "mark_freebie", "mark_clarity", "mark_general", "last_name"`.
 * Если передано `'last_name'` - возвращается список преподавателей отсортированных по алфавиту по фамилиям
 * Если передано `'mark_...'` - возвращается список преподавателей отсортированных по конкретной оценке
 * Если передано просто так (или с '+' в начале параметра), то сортирует по возрастанию
 * С '-' в начале -- по убыванию.
 *
 * *Пример запросов с этим параметром*:
 * - `...?order_by=-mark_kindness`
 * - `...?order_by=mark_freebie`
 * - `...?order_by=+mark_freebie` (эквивалентно 2ому пункту)
 *
 * `info` - возможные значения `'comments'`.
 * Если передано `'comments'`, то возвращаются одобренные комментарии к преподавателю.
 *
 * `subject`
 * Если передано `subject` - возвращает всех преподавателей, для которых переданное значение совпадает с одним из их предметов преподавания.
 * Также возвращает всех преподавателей, у которых есть комментарий с совпадающим с данным subject.
 *
 * `name`
 * Поле для ФИО. Если передано `name` - возвращает всех преподователей, для которых нашлись совпадения с переданной строкой
 *
 * `mark`
 * Поле для оценки. Если передано, то возвращает только тех преподавателей, для которых средняя общая оценка ('general_mark')
 * больше, чем переданный 'mark'.
 */
export const getLecturersLecturerGetInfiniteOptions = (options?: Options<GetLecturersLecturerGetData>) => {
    return infiniteQueryOptions<GetLecturersLecturerGetResponse, GetLecturersLecturerGetError, InfiniteData<GetLecturersLecturerGetResponse>, QueryKey<Options<GetLecturersLecturerGetData>>, number | Pick<QueryKey<Options<GetLecturersLecturerGetData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetLecturersLecturerGetData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    offset: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getLecturersLecturerGet({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLecturersLecturerGetInfiniteQueryKey(options)
    });
};

/**
 * Create Lecturer
 *
 * Scopes: `["rating.lecturer.create"]`
 *
 * Создает преподавателя в базе данных RatingAPI
 */
export const createLecturerLecturerPostMutation = (options?: Partial<Options<CreateLecturerLecturerPostData>>): UseMutationOptions<CreateLecturerLecturerPostResponse, CreateLecturerLecturerPostError, Options<CreateLecturerLecturerPostData>> => {
    const mutationOptions: UseMutationOptions<CreateLecturerLecturerPostResponse, CreateLecturerLecturerPostError, Options<CreateLecturerLecturerPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createLecturerLecturerPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Lecturer Rating
 *
 * Scopes: `["rating.lecturer.update_rating"]`
 *
 * Обновляет рейтинг преподавателя в базе данных RatingAPI
 */
export const updateLecturerRatingLecturerImportRatingPatchMutation = (options?: Partial<Options<UpdateLecturerRatingLecturerImportRatingPatchData>>): UseMutationOptions<UpdateLecturerRatingLecturerImportRatingPatchResponse, UpdateLecturerRatingLecturerImportRatingPatchError, Options<UpdateLecturerRatingLecturerImportRatingPatchData>> => {
    const mutationOptions: UseMutationOptions<UpdateLecturerRatingLecturerImportRatingPatchResponse, UpdateLecturerRatingLecturerImportRatingPatchError, Options<UpdateLecturerRatingLecturerImportRatingPatchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateLecturerRatingLecturerImportRatingPatch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Lecturer
 *
 * Scopes: `["rating.lecturer.delete"]`
 */
export const deleteLecturerLecturerIdDeleteMutation = (options?: Partial<Options<DeleteLecturerLecturerIdDeleteData>>): UseMutationOptions<DeleteLecturerLecturerIdDeleteResponse, DeleteLecturerLecturerIdDeleteError, Options<DeleteLecturerLecturerIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteLecturerLecturerIdDeleteResponse, DeleteLecturerLecturerIdDeleteError, Options<DeleteLecturerLecturerIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteLecturerLecturerIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getLecturerLecturerIdGetQueryKey = (options: Options<GetLecturerLecturerIdGetData>) => createQueryKey('getLecturerLecturerIdGet', options);

/**
 * Get Lecturer
 *
 * Scopes: `["rating.lecturer.read"]`
 *
 * Возвращает преподавателя по его ID в базе данных RatingAPI
 *
 * *QUERY* `info: string` - возможные значения `'comments'`.
 * Если передано `'comments'`, то возвращаются одобренные комментарии к преподавателю.
 * Subject лектора возвращшается либо из базы данных, либо из любого аппрувнутого комментария
 */
export const getLecturerLecturerIdGetOptions = (options: Options<GetLecturerLecturerIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLecturerLecturerIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLecturerLecturerIdGetQueryKey(options)
    });
};

/**
 * Update Lecturer
 *
 * Scopes: `["rating.lecturer.update"]`
 */
export const updateLecturerLecturerIdPatchMutation = (options?: Partial<Options<UpdateLecturerLecturerIdPatchData>>): UseMutationOptions<UpdateLecturerLecturerIdPatchResponse, UpdateLecturerLecturerIdPatchError, Options<UpdateLecturerLecturerIdPatchData>> => {
    const mutationOptions: UseMutationOptions<UpdateLecturerLecturerIdPatchResponse, UpdateLecturerLecturerIdPatchError, Options<UpdateLecturerLecturerIdPatchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateLecturerLecturerIdPatch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCommentsCommentGetQueryKey = (options?: Options<GetCommentsCommentGetData>) => createQueryKey('getCommentsCommentGet', options);

/**
 * Get Comments
 *
 * Scopes: `["rating.comment.review"]`
 *
 * `limit` - максимальное количество возвращаемых комментариев
 *
 * `offset` -  смещение, определяющее, с какого по порядку комментария начинать выборку.
 * Если без смещения возвращается комментарий с условным номером N,
 * то при значении offset = X будет возвращаться комментарий с номером N + X
 *
 * `order_by` - возможные значения `"create_ts", "mark_kindness", "mark_freebie", "mark_clarity", "mark_general"`.
 * Если передано `'create_ts'` - возвращается список комментариев отсортированных по времени
 * Если передано `'mark_...'` - возвращается список комментариев отсортированных по конкретной оценке
 *
 * `lecturer_id` - вернет все комментарии для преподавателя с конкретным id, по дефолту возвращает вообще все аппрувнутые комментарии.
 *
 * `user_id` - вернет все комментарии пользователя с конкретным id
 *
 * `unreviewed` - вернет все непроверенные комментарии, если True. По дефолту False.
 *
 * `asc_order` -Если передано true, сортировать в порядке возрастания. Иначе - в порядке убывания
 */
export const getCommentsCommentGetOptions = (options?: Options<GetCommentsCommentGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCommentsCommentGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCommentsCommentGetQueryKey(options)
    });
};

export const getCommentsCommentGetInfiniteQueryKey = (options?: Options<GetCommentsCommentGetData>): QueryKey<Options<GetCommentsCommentGetData>> => createQueryKey('getCommentsCommentGet', options, true);

/**
 * Get Comments
 *
 * Scopes: `["rating.comment.review"]`
 *
 * `limit` - максимальное количество возвращаемых комментариев
 *
 * `offset` -  смещение, определяющее, с какого по порядку комментария начинать выборку.
 * Если без смещения возвращается комментарий с условным номером N,
 * то при значении offset = X будет возвращаться комментарий с номером N + X
 *
 * `order_by` - возможные значения `"create_ts", "mark_kindness", "mark_freebie", "mark_clarity", "mark_general"`.
 * Если передано `'create_ts'` - возвращается список комментариев отсортированных по времени
 * Если передано `'mark_...'` - возвращается список комментариев отсортированных по конкретной оценке
 *
 * `lecturer_id` - вернет все комментарии для преподавателя с конкретным id, по дефолту возвращает вообще все аппрувнутые комментарии.
 *
 * `user_id` - вернет все комментарии пользователя с конкретным id
 *
 * `unreviewed` - вернет все непроверенные комментарии, если True. По дефолту False.
 *
 * `asc_order` -Если передано true, сортировать в порядке возрастания. Иначе - в порядке убывания
 */
export const getCommentsCommentGetInfiniteOptions = (options?: Options<GetCommentsCommentGetData>) => {
    return infiniteQueryOptions<GetCommentsCommentGetResponse, GetCommentsCommentGetError, InfiniteData<GetCommentsCommentGetResponse>, QueryKey<Options<GetCommentsCommentGetData>>, number | Pick<QueryKey<Options<GetCommentsCommentGetData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetCommentsCommentGetData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    offset: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getCommentsCommentGet({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCommentsCommentGetInfiniteQueryKey(options)
    });
};

/**
 * Create Comment
 *
 * Создает комментарий к преподавателю в базе данных RatingAPI
 * Для создания комментария нужно быть авторизованным
 */
export const createCommentCommentPostMutation = (options?: Partial<Options<CreateCommentCommentPostData>>): UseMutationOptions<CreateCommentCommentPostResponse, CreateCommentCommentPostError, Options<CreateCommentCommentPostData>> => {
    const mutationOptions: UseMutationOptions<CreateCommentCommentPostResponse, CreateCommentCommentPostError, Options<CreateCommentCommentPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createCommentCommentPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Import Comments
 *
 * Scopes: `["rating.comment.import"]`
 * Создает комментарии в базе данных RatingAPI
 */
export const importCommentsCommentImportPostMutation = (options?: Partial<Options<ImportCommentsCommentImportPostData>>): UseMutationOptions<ImportCommentsCommentImportPostResponse, ImportCommentsCommentImportPostError, Options<ImportCommentsCommentImportPostData>> => {
    const mutationOptions: UseMutationOptions<ImportCommentsCommentImportPostResponse, ImportCommentsCommentImportPostError, Options<ImportCommentsCommentImportPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await importCommentsCommentImportPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Comment
 *
 * Scopes: `["rating.comment.delete"]`
 *
 * Удаляет комментарий по его UUID в базе данных RatingAPI
 */
export const deleteCommentCommentUuidDeleteMutation = (options?: Partial<Options<DeleteCommentCommentUuidDeleteData>>): UseMutationOptions<DeleteCommentCommentUuidDeleteResponse, DeleteCommentCommentUuidDeleteError, Options<DeleteCommentCommentUuidDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteCommentCommentUuidDeleteResponse, DeleteCommentCommentUuidDeleteError, Options<DeleteCommentCommentUuidDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCommentCommentUuidDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCommentCommentUuidGetQueryKey = (options: Options<GetCommentCommentUuidGetData>) => createQueryKey('getCommentCommentUuidGet', options);

/**
 * Get Comment
 *
 * Возвращает комментарий по его UUID в базе данных RatingAPI
 */
export const getCommentCommentUuidGetOptions = (options: Options<GetCommentCommentUuidGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCommentCommentUuidGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCommentCommentUuidGetQueryKey(options)
    });
};

/**
 * Update Comment
 *
 * Позволяет изменить свой неанонимный комментарий
 */
export const updateCommentCommentUuidPatchMutation = (options?: Partial<Options<UpdateCommentCommentUuidPatchData>>): UseMutationOptions<UpdateCommentCommentUuidPatchResponse, UpdateCommentCommentUuidPatchError, Options<UpdateCommentCommentUuidPatchData>> => {
    const mutationOptions: UseMutationOptions<UpdateCommentCommentUuidPatchResponse, UpdateCommentCommentUuidPatchError, Options<UpdateCommentCommentUuidPatchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateCommentCommentUuidPatch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Review Comment
 *
 * Scopes: `["rating.comment.review"]`
 * Проверка комментария и присваивания ему статуса по его UUID в базе данных RatingAPI
 *
 * `review_status` - возможные значения
 * `approved` - комментарий одобрен и возвращается при запросе лектора
 * `dismissed` - комментарий отклонен, не отображается в запросе лектора
 */
export const reviewCommentCommentUuidReviewPatchMutation = (options?: Partial<Options<ReviewCommentCommentUuidReviewPatchData>>): UseMutationOptions<ReviewCommentCommentUuidReviewPatchResponse, ReviewCommentCommentUuidReviewPatchError, Options<ReviewCommentCommentUuidReviewPatchData>> => {
    const mutationOptions: UseMutationOptions<ReviewCommentCommentUuidReviewPatchResponse, ReviewCommentCommentUuidReviewPatchError, Options<ReviewCommentCommentUuidReviewPatchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await reviewCommentCommentUuidReviewPatch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Like Comment
 *
 * Handles like/dislike reactions for a comment.
 *
 * This endpoint allows authenticated users to react to a comment (like/dislike) or change their existing reaction.
 * If the user has no existing reaction, a new one is created. If the user changes their reaction, it gets updated.
 * If the user clicks the same reaction again, the reaction is removed.
 *
 * Args:
 * uuid (UUID): The UUID of the comment to react to.
 * reaction (Reaction): The reaction type (like/dislike).
 * user (dict): Authenticated user data from UnionAuth dependency.
 *
 * Returns:
 * CommentGet: The updated comment with reactions in CommentGet format.
 *
 * Raises:
 * ObjectNotFound: If the comment with given UUID doesn't exist.
 */
export const likeCommentCommentUuidReactionPutMutation = (options?: Partial<Options<LikeCommentCommentUuidReactionPutData>>): UseMutationOptions<LikeCommentCommentUuidReactionPutResponse, LikeCommentCommentUuidReactionPutError, Options<LikeCommentCommentUuidReactionPutData>> => {
    const mutationOptions: UseMutationOptions<LikeCommentCommentUuidReactionPutResponse, LikeCommentCommentUuidReactionPutError, Options<LikeCommentCommentUuidReactionPutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await likeCommentCommentUuidReactionPut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

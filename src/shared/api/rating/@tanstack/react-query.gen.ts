// This file is auto-generated by @hey-api/openapi-ts

import {
	type InfiniteData,
	type UseMutationOptions,
	infiniteQueryOptions,
	queryOptions,
} from '@tanstack/react-query';
import { client as _heyApiClient } from '../client.gen';
import {
	type Options,
	createCommentCommentPost,
	createLecturerLecturerPost,
	deleteCommentCommentUuidDelete,
	deleteLecturerLecturerIdDelete,
	getCommentCommentUuidGet,
	getCommentsCommentGet,
	getLecturerLecturerIdGet,
	getLecturersLecturerGet,
	importCommentsCommentImportPost,
	reviewCommentCommentUuidPatch,
	updateLecturerLecturerIdPatch,
} from '../sdk.gen';
import type {
	CreateCommentCommentPostData,
	CreateCommentCommentPostError,
	CreateCommentCommentPostResponse,
	CreateLecturerLecturerPostData,
	CreateLecturerLecturerPostError,
	CreateLecturerLecturerPostResponse,
	DeleteCommentCommentUuidDeleteData,
	DeleteCommentCommentUuidDeleteError,
	DeleteCommentCommentUuidDeleteResponse,
	DeleteLecturerLecturerIdDeleteData,
	DeleteLecturerLecturerIdDeleteError,
	DeleteLecturerLecturerIdDeleteResponse,
	GetCommentCommentUuidGetData,
	GetCommentsCommentGetData,
	GetCommentsCommentGetError,
	GetCommentsCommentGetResponse,
	GetLecturerLecturerIdGetData,
	GetLecturersLecturerGetData,
	GetLecturersLecturerGetError,
	GetLecturersLecturerGetResponse,
	ImportCommentsCommentImportPostData,
	ImportCommentsCommentImportPostError,
	ImportCommentsCommentImportPostResponse,
	ReviewCommentCommentUuidPatchData,
	ReviewCommentCommentUuidPatchError,
	ReviewCommentCommentUuidPatchResponse,
	UpdateLecturerLecturerIdPatchData,
	UpdateLecturerLecturerIdPatchError,
	UpdateLecturerLecturerIdPatchResponse,
} from '../types.gen';

export type QueryKey<TOptions extends Options> = [
	Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
		_id: string;
		_infinite?: boolean;
	},
];

const createQueryKey = <TOptions extends Options>(
	id: string,
	options?: TOptions,
	infinite?: boolean
): [QueryKey<TOptions>[0]] => {
	const params: QueryKey<TOptions>[0] = {
		_id: id,
		baseUrl: (options?.client ?? _heyApiClient).getConfig().baseUrl,
	} as QueryKey<TOptions>[0];
	if (infinite) {
		params._infinite = infinite;
	}
	if (options?.body) {
		params.body = options.body;
	}
	if (options?.headers) {
		params.headers = options.headers;
	}
	if (options?.path) {
		params.path = options.path;
	}
	if (options?.query) {
		params.query = options.query;
	}
	return [params];
};

export const getLecturersLecturerGetQueryKey = (options?: Options<GetLecturersLecturerGetData>) =>
	createQueryKey('getLecturersLecturerGet', options);

export const getLecturersLecturerGetOptions = (options?: Options<GetLecturersLecturerGetData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await getLecturersLecturerGet({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: getLecturersLecturerGetQueryKey(options),
	});
};

const createInfiniteParams = <
	K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>,
>(
	queryKey: QueryKey<Options>,
	page: K
) => {
	const params = queryKey[0];
	if (page.body) {
		params.body = {
			...(queryKey[0].body as any),
			...(page.body as any),
		};
	}
	if (page.headers) {
		params.headers = {
			...queryKey[0].headers,
			...page.headers,
		};
	}
	if (page.path) {
		params.path = {
			...(queryKey[0].path as any),
			...(page.path as any),
		};
	}
	if (page.query) {
		params.query = {
			...(queryKey[0].query as any),
			...(page.query as any),
		};
	}
	return params as unknown as typeof page;
};

export const getLecturersLecturerGetInfiniteQueryKey = (
	options?: Options<GetLecturersLecturerGetData>
): QueryKey<Options<GetLecturersLecturerGetData>> =>
	createQueryKey('getLecturersLecturerGet', options, true);

export const getLecturersLecturerGetInfiniteOptions = (
	options?: Options<GetLecturersLecturerGetData>
) => {
	return infiniteQueryOptions<
		GetLecturersLecturerGetResponse,
		GetLecturersLecturerGetError,
		InfiniteData<GetLecturersLecturerGetResponse>,
		QueryKey<Options<GetLecturersLecturerGetData>>,
		| number
		| Pick<QueryKey<Options<GetLecturersLecturerGetData>>[0], 'body' | 'headers' | 'path' | 'query'>
	>(
		// @ts-ignore
		{
			queryFn: async ({ pageParam, queryKey, signal }) => {
				// @ts-ignore
				const page: Pick<
					QueryKey<Options<GetLecturersLecturerGetData>>[0],
					'body' | 'headers' | 'path' | 'query'
				> =
					typeof pageParam === 'object'
						? pageParam
						: {
								query: {
									offset: pageParam,
								},
							};
				const params = createInfiniteParams(queryKey, page);
				const { data } = await getLecturersLecturerGet({
					...options,
					...params,
					signal,
					throwOnError: true,
				});
				return data;
			},
			queryKey: getLecturersLecturerGetInfiniteQueryKey(options),
		}
	);
};

export const createLecturerLecturerPostQueryKey = (
	options: Options<CreateLecturerLecturerPostData>
) => createQueryKey('createLecturerLecturerPost', options);

export const createLecturerLecturerPostOptions = (
	options: Options<CreateLecturerLecturerPostData>
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await createLecturerLecturerPost({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: createLecturerLecturerPostQueryKey(options),
	});
};

export const createLecturerLecturerPostMutation = (
	options?: Partial<Options<CreateLecturerLecturerPostData>>
) => {
	const mutationOptions: UseMutationOptions<
		CreateLecturerLecturerPostResponse,
		CreateLecturerLecturerPostError,
		Options<CreateLecturerLecturerPostData>
	> = {
		mutationFn: async localOptions => {
			const { data } = await createLecturerLecturerPost({
				...options,
				...localOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const deleteLecturerLecturerIdDeleteMutation = (
	options?: Partial<Options<DeleteLecturerLecturerIdDeleteData>>
) => {
	const mutationOptions: UseMutationOptions<
		DeleteLecturerLecturerIdDeleteResponse,
		DeleteLecturerLecturerIdDeleteError,
		Options<DeleteLecturerLecturerIdDeleteData>
	> = {
		mutationFn: async localOptions => {
			const { data } = await deleteLecturerLecturerIdDelete({
				...options,
				...localOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const getLecturerLecturerIdGetQueryKey = (options: Options<GetLecturerLecturerIdGetData>) =>
	createQueryKey('getLecturerLecturerIdGet', options);

export const getLecturerLecturerIdGetOptions = (options: Options<GetLecturerLecturerIdGetData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await getLecturerLecturerIdGet({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: getLecturerLecturerIdGetQueryKey(options),
	});
};

export const updateLecturerLecturerIdPatchMutation = (
	options?: Partial<Options<UpdateLecturerLecturerIdPatchData>>
) => {
	const mutationOptions: UseMutationOptions<
		UpdateLecturerLecturerIdPatchResponse,
		UpdateLecturerLecturerIdPatchError,
		Options<UpdateLecturerLecturerIdPatchData>
	> = {
		mutationFn: async localOptions => {
			const { data } = await updateLecturerLecturerIdPatch({
				...options,
				...localOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const getCommentsCommentGetQueryKey = (options?: Options<GetCommentsCommentGetData>) =>
	createQueryKey('getCommentsCommentGet', options);

export const getCommentsCommentGetOptions = (options?: Options<GetCommentsCommentGetData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await getCommentsCommentGet({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: getCommentsCommentGetQueryKey(options),
	});
};

export const getCommentsCommentGetInfiniteQueryKey = (
	options?: Options<GetCommentsCommentGetData>
): QueryKey<Options<GetCommentsCommentGetData>> =>
	createQueryKey('getCommentsCommentGet', options, true);

export const getCommentsCommentGetInfiniteOptions = (
	options?: Options<GetCommentsCommentGetData>
) => {
	return infiniteQueryOptions<
		GetCommentsCommentGetResponse,
		GetCommentsCommentGetError,
		InfiniteData<GetCommentsCommentGetResponse>,
		QueryKey<Options<GetCommentsCommentGetData>>,
		| number
		| Pick<QueryKey<Options<GetCommentsCommentGetData>>[0], 'body' | 'headers' | 'path' | 'query'>
	>(
		// @ts-ignore
		{
			queryFn: async ({ pageParam, queryKey, signal }) => {
				// @ts-ignore
				const page: Pick<
					QueryKey<Options<GetCommentsCommentGetData>>[0],
					'body' | 'headers' | 'path' | 'query'
				> =
					typeof pageParam === 'object'
						? pageParam
						: {
								query: {
									offset: pageParam,
								},
							};
				const params = createInfiniteParams(queryKey, page);
				const { data } = await getCommentsCommentGet({
					...options,
					...params,
					signal,
					throwOnError: true,
				});
				return data;
			},
			queryKey: getCommentsCommentGetInfiniteQueryKey(options),
		}
	);
};

export const createCommentCommentPostQueryKey = (options: Options<CreateCommentCommentPostData>) =>
	createQueryKey('createCommentCommentPost', options);

export const createCommentCommentPostOptions = (options: Options<CreateCommentCommentPostData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await createCommentCommentPost({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: createCommentCommentPostQueryKey(options),
	});
};

export const createCommentCommentPostMutation = (
	options?: Partial<Options<CreateCommentCommentPostData>>
) => {
	const mutationOptions: UseMutationOptions<
		CreateCommentCommentPostResponse,
		CreateCommentCommentPostError,
		Options<CreateCommentCommentPostData>
	> = {
		mutationFn: async localOptions => {
			const { data } = await createCommentCommentPost({
				...options,
				...localOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const importCommentsCommentImportPostQueryKey = (
	options: Options<ImportCommentsCommentImportPostData>
) => createQueryKey('importCommentsCommentImportPost', options);

export const importCommentsCommentImportPostOptions = (
	options: Options<ImportCommentsCommentImportPostData>
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await importCommentsCommentImportPost({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: importCommentsCommentImportPostQueryKey(options),
	});
};

export const importCommentsCommentImportPostMutation = (
	options?: Partial<Options<ImportCommentsCommentImportPostData>>
) => {
	const mutationOptions: UseMutationOptions<
		ImportCommentsCommentImportPostResponse,
		ImportCommentsCommentImportPostError,
		Options<ImportCommentsCommentImportPostData>
	> = {
		mutationFn: async localOptions => {
			const { data } = await importCommentsCommentImportPost({
				...options,
				...localOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const deleteCommentCommentUuidDeleteMutation = (
	options?: Partial<Options<DeleteCommentCommentUuidDeleteData>>
) => {
	const mutationOptions: UseMutationOptions<
		DeleteCommentCommentUuidDeleteResponse,
		DeleteCommentCommentUuidDeleteError,
		Options<DeleteCommentCommentUuidDeleteData>
	> = {
		mutationFn: async localOptions => {
			const { data } = await deleteCommentCommentUuidDelete({
				...options,
				...localOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const getCommentCommentUuidGetQueryKey = (options: Options<GetCommentCommentUuidGetData>) =>
	createQueryKey('getCommentCommentUuidGet', options);

export const getCommentCommentUuidGetOptions = (options: Options<GetCommentCommentUuidGetData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await getCommentCommentUuidGet({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: getCommentCommentUuidGetQueryKey(options),
	});
};

export const reviewCommentCommentUuidPatchMutation = (
	options?: Partial<Options<ReviewCommentCommentUuidPatchData>>
) => {
	const mutationOptions: UseMutationOptions<
		ReviewCommentCommentUuidPatchResponse,
		ReviewCommentCommentUuidPatchError,
		Options<ReviewCommentCommentUuidPatchData>
	> = {
		mutationFn: async localOptions => {
			const { data } = await reviewCommentCommentUuidPatch({
				...options,
				...localOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

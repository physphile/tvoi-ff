// This file is auto-generated by @hey-api/openapi-ts

import type { Client, Options as Options2, TDataShape } from './client';
import { client } from './client.gen';
import type { CreateCommentCommentPostData, CreateCommentCommentPostErrors, CreateCommentCommentPostResponses, CreateLecturerLecturerPostData, CreateLecturerLecturerPostErrors, CreateLecturerLecturerPostResponses, DeleteCommentCommentUuidDeleteData, DeleteCommentCommentUuidDeleteErrors, DeleteCommentCommentUuidDeleteResponses, DeleteLecturerLecturerIdDeleteData, DeleteLecturerLecturerIdDeleteErrors, DeleteLecturerLecturerIdDeleteResponses, GetCommentCommentUuidGetData, GetCommentCommentUuidGetErrors, GetCommentCommentUuidGetResponses, GetCommentsCommentGetData, GetCommentsCommentGetErrors, GetCommentsCommentGetResponses, GetLecturerLecturerIdGetData, GetLecturerLecturerIdGetErrors, GetLecturerLecturerIdGetResponses, GetLecturersLecturerGetData, GetLecturersLecturerGetErrors, GetLecturersLecturerGetResponses, ImportCommentsCommentImportPostData, ImportCommentsCommentImportPostErrors, ImportCommentsCommentImportPostResponses, LikeCommentCommentUuidReactionPutData, LikeCommentCommentUuidReactionPutErrors, LikeCommentCommentUuidReactionPutResponses, ReviewCommentCommentUuidReviewPatchData, ReviewCommentCommentUuidReviewPatchErrors, ReviewCommentCommentUuidReviewPatchResponses, UpdateCommentCommentUuidPatchData, UpdateCommentCommentUuidPatchErrors, UpdateCommentCommentUuidPatchResponses, UpdateLecturerLecturerIdPatchData, UpdateLecturerLecturerIdPatchErrors, UpdateLecturerLecturerIdPatchResponses, UpdateLecturerRatingLecturerImportRatingPatchData, UpdateLecturerRatingLecturerImportRatingPatchErrors, UpdateLecturerRatingLecturerImportRatingPatchResponses } from './types.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = Options2<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Get Lecturers
 *
 * `limit` - максимальное количество возвращаемых преподавателей
 *
 * `offset` - нижняя граница получения преподавателей, т.е. если по дефолту первым возвращается преподаватель с условным номером N, то при наличии ненулевого offset будет возвращаться преподаватель с номером N + offset
 *
 * `order_by` - возможные значения `"mark_weighted", "mark_kindness", "mark_freebie", "mark_clarity", "mark_general", "last_name"`.
 * Если передано `'last_name'` - возвращается список преподавателей отсортированных по алфавиту по фамилиям
 * Если передано `'mark_...'` - возвращается список преподавателей отсортированных по конкретной оценке
 * Если передано просто так (или с '+' в начале параметра), то сортирует по возрастанию
 * С '-' в начале -- по убыванию.
 *
 * *Пример запросов с этим параметром*:
 * - `...?order_by=-mark_kindness`
 * - `...?order_by=mark_freebie`
 * - `...?order_by=+mark_freebie` (эквивалентно 2ому пункту)
 *
 * `info` - возможные значения `'comments'`.
 * Если передано `'comments'`, то возвращаются одобренные комментарии к преподавателю.
 *
 * `subject`
 * Если передано `subject` - возвращает всех преподавателей, для которых переданное значение совпадает с одним из их предметов преподавания.
 * Также возвращает всех преподавателей, у которых есть комментарий с совпадающим с данным subject.
 *
 * `name`
 * Поле для ФИО. Если передано `name` - возвращает всех преподователей, для которых нашлись совпадения с переданной строкой
 *
 * `mark`
 * Поле для оценки. Если передано, то возвращает только тех преподавателей, для которых средняя общая оценка ('general_mark')
 * больше, чем переданный 'mark'.
 */
export const getLecturersLecturerGet = <ThrowOnError extends boolean = false>(options?: Options<GetLecturersLecturerGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLecturersLecturerGetResponses, GetLecturersLecturerGetErrors, ThrowOnError>({
        url: '/lecturer',
        ...options
    });
};

/**
 * Create Lecturer
 *
 * Scopes: `["rating.lecturer.create"]`
 *
 * Создает преподавателя в базе данных RatingAPI
 */
export const createLecturerLecturerPost = <ThrowOnError extends boolean = false>(options: Options<CreateLecturerLecturerPostData, ThrowOnError>) => {
    return (options.client ?? client).post<CreateLecturerLecturerPostResponses, CreateLecturerLecturerPostErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/lecturer',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Update Lecturer Rating
 *
 * Scopes: `["rating.lecturer.update_rating"]`
 *
 * Обновляет рейтинг преподавателя в базе данных RatingAPI
 */
export const updateLecturerRatingLecturerImportRatingPatch = <ThrowOnError extends boolean = false>(options: Options<UpdateLecturerRatingLecturerImportRatingPatchData, ThrowOnError>) => {
    return (options.client ?? client).patch<UpdateLecturerRatingLecturerImportRatingPatchResponses, UpdateLecturerRatingLecturerImportRatingPatchErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/lecturer/import_rating',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete Lecturer
 *
 * Scopes: `["rating.lecturer.delete"]`
 */
export const deleteLecturerLecturerIdDelete = <ThrowOnError extends boolean = false>(options: Options<DeleteLecturerLecturerIdDeleteData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteLecturerLecturerIdDeleteResponses, DeleteLecturerLecturerIdDeleteErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/lecturer/{id}',
        ...options
    });
};

/**
 * Get Lecturer
 *
 * Scopes: `["rating.lecturer.read"]`
 *
 * Возвращает преподавателя по его ID в базе данных RatingAPI
 *
 * *QUERY* `info: string` - возможные значения `'comments'`.
 * Если передано `'comments'`, то возвращаются одобренные комментарии к преподавателю.
 * Subject лектора возвращшается либо из базы данных, либо из любого аппрувнутого комментария
 */
export const getLecturerLecturerIdGet = <ThrowOnError extends boolean = false>(options: Options<GetLecturerLecturerIdGetData, ThrowOnError>) => {
    return (options.client ?? client).get<GetLecturerLecturerIdGetResponses, GetLecturerLecturerIdGetErrors, ThrowOnError>({
        url: '/lecturer/{id}',
        ...options
    });
};

/**
 * Update Lecturer
 *
 * Scopes: `["rating.lecturer.update"]`
 */
export const updateLecturerLecturerIdPatch = <ThrowOnError extends boolean = false>(options: Options<UpdateLecturerLecturerIdPatchData, ThrowOnError>) => {
    return (options.client ?? client).patch<UpdateLecturerLecturerIdPatchResponses, UpdateLecturerLecturerIdPatchErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/lecturer/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get Comments
 *
 * Scopes: `["rating.comment.review"]`
 *
 * `limit` - максимальное количество возвращаемых комментариев
 *
 * `offset` -  смещение, определяющее, с какого по порядку комментария начинать выборку.
 * Если без смещения возвращается комментарий с условным номером N,
 * то при значении offset = X будет возвращаться комментарий с номером N + X
 *
 * `order_by` - возможные значения `"create_ts", "mark_kindness", "mark_freebie", "mark_clarity", "mark_general"`.
 * Если передано `'create_ts'` - возвращается список комментариев отсортированных по времени
 * Если передано `'mark_...'` - возвращается список комментариев отсортированных по конкретной оценке
 *
 * `lecturer_id` - вернет все комментарии для преподавателя с конкретным id, по дефолту возвращает вообще все аппрувнутые комментарии.
 *
 * `user_id` - вернет все комментарии пользователя с конкретным id
 *
 * `unreviewed` - вернет все непроверенные комментарии, если True. По дефолту False.
 *
 * `asc_order` -Если передано true, сортировать в порядке возрастания. Иначе - в порядке убывания
 */
export const getCommentsCommentGet = <ThrowOnError extends boolean = false>(options?: Options<GetCommentsCommentGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetCommentsCommentGetResponses, GetCommentsCommentGetErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/comment',
        ...options
    });
};

/**
 * Create Comment
 *
 * Создает комментарий к преподавателю в базе данных RatingAPI
 * Для создания комментария нужно быть авторизованным
 */
export const createCommentCommentPost = <ThrowOnError extends boolean = false>(options: Options<CreateCommentCommentPostData, ThrowOnError>) => {
    return (options.client ?? client).post<CreateCommentCommentPostResponses, CreateCommentCommentPostErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/comment',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Import Comments
 *
 * Scopes: `["rating.comment.import"]`
 * Создает комментарии в базе данных RatingAPI
 */
export const importCommentsCommentImportPost = <ThrowOnError extends boolean = false>(options: Options<ImportCommentsCommentImportPostData, ThrowOnError>) => {
    return (options.client ?? client).post<ImportCommentsCommentImportPostResponses, ImportCommentsCommentImportPostErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/comment/import',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete Comment
 *
 * Scopes: `["rating.comment.delete"]`
 *
 * Удаляет комментарий по его UUID в базе данных RatingAPI
 */
export const deleteCommentCommentUuidDelete = <ThrowOnError extends boolean = false>(options: Options<DeleteCommentCommentUuidDeleteData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteCommentCommentUuidDeleteResponses, DeleteCommentCommentUuidDeleteErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/comment/{uuid}',
        ...options
    });
};

/**
 * Get Comment
 *
 * Возвращает комментарий по его UUID в базе данных RatingAPI
 */
export const getCommentCommentUuidGet = <ThrowOnError extends boolean = false>(options: Options<GetCommentCommentUuidGetData, ThrowOnError>) => {
    return (options.client ?? client).get<GetCommentCommentUuidGetResponses, GetCommentCommentUuidGetErrors, ThrowOnError>({
        url: '/comment/{uuid}',
        ...options
    });
};

/**
 * Update Comment
 *
 * Позволяет изменить свой неанонимный комментарий
 */
export const updateCommentCommentUuidPatch = <ThrowOnError extends boolean = false>(options: Options<UpdateCommentCommentUuidPatchData, ThrowOnError>) => {
    return (options.client ?? client).patch<UpdateCommentCommentUuidPatchResponses, UpdateCommentCommentUuidPatchErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/comment/{uuid}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Review Comment
 *
 * Scopes: `["rating.comment.review"]`
 * Проверка комментария и присваивания ему статуса по его UUID в базе данных RatingAPI
 *
 * `review_status` - возможные значения
 * `approved` - комментарий одобрен и возвращается при запросе лектора
 * `dismissed` - комментарий отклонен, не отображается в запросе лектора
 */
export const reviewCommentCommentUuidReviewPatch = <ThrowOnError extends boolean = false>(options: Options<ReviewCommentCommentUuidReviewPatchData, ThrowOnError>) => {
    return (options.client ?? client).patch<ReviewCommentCommentUuidReviewPatchResponses, ReviewCommentCommentUuidReviewPatchErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/comment/{uuid}/review',
        ...options
    });
};

/**
 * Like Comment
 *
 * Handles like/dislike reactions for a comment.
 *
 * This endpoint allows authenticated users to react to a comment (like/dislike) or change their existing reaction.
 * If the user has no existing reaction, a new one is created. If the user changes their reaction, it gets updated.
 * If the user clicks the same reaction again, the reaction is removed.
 *
 * Args:
 * uuid (UUID): The UUID of the comment to react to.
 * reaction (Reaction): The reaction type (like/dislike).
 * user (dict): Authenticated user data from UnionAuth dependency.
 *
 * Returns:
 * CommentGet: The updated comment with reactions in CommentGet format.
 *
 * Raises:
 * ObjectNotFound: If the comment with given UUID doesn't exist.
 */
export const likeCommentCommentUuidReactionPut = <ThrowOnError extends boolean = false>(options: Options<LikeCommentCommentUuidReactionPutData, ThrowOnError>) => {
    return (options.client ?? client).put<LikeCommentCommentUuidReactionPutResponses, LikeCommentCommentUuidReactionPutErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/comment/{uuid}/{reaction}',
        ...options
    });
};

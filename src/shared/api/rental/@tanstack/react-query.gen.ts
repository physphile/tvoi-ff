// This file is auto-generated by @hey-api/openapi-ts

import { queryOptions, type UseMutationOptions } from '@tanstack/react-query';

import { client } from '../client.gen';
import { acceptEndRentalSessionRentalSessionsSessionIdReturnPatch, cancelRentalSessionRentalSessionsSessionIdCancelDelete, createItemItemPost, createItemTypeItemtypePost, createRentalSessionRentalSessionsItemTypeIdPost, createStrikeStrikePost, deleteItemItemIdDelete, deleteItemTypeItemtypeIdDelete, deleteStrikeStrikeIdDelete, getEventsEventGet, getItemItemIdGet, getItemsItemGet, getItemsTypesItemtypeGet, getItemTypeItemtypeIdGet, getMySessionsRentalSessionsUserMeGet, getRentalSessionRentalSessionsSessionIdGet, getRentalSessionsRentalSessionsGet, getStrikesStrikeGet, getUserStrikesStrikeUserUserIdGet, makeItemTypeAvailableItemtypeAvailableIdPatch, type Options, startRentalSessionRentalSessionsSessionIdStartPatch, updateItemItemIdPatch, updateItemTypeItemtypeIdPatch, updateRentalSessionRentalSessionsSessionIdPatch } from '../sdk.gen';
import type { AcceptEndRentalSessionRentalSessionsSessionIdReturnPatchData, AcceptEndRentalSessionRentalSessionsSessionIdReturnPatchError, AcceptEndRentalSessionRentalSessionsSessionIdReturnPatchResponse, CancelRentalSessionRentalSessionsSessionIdCancelDeleteData, CancelRentalSessionRentalSessionsSessionIdCancelDeleteError, CancelRentalSessionRentalSessionsSessionIdCancelDeleteResponse, CreateItemItemPostData, CreateItemItemPostError, CreateItemItemPostResponse, CreateItemTypeItemtypePostData, CreateItemTypeItemtypePostError, CreateItemTypeItemtypePostResponse, CreateRentalSessionRentalSessionsItemTypeIdPostData, CreateRentalSessionRentalSessionsItemTypeIdPostError, CreateRentalSessionRentalSessionsItemTypeIdPostResponse, CreateStrikeStrikePostData, CreateStrikeStrikePostError, CreateStrikeStrikePostResponse, DeleteItemItemIdDeleteData, DeleteItemItemIdDeleteError, DeleteItemItemIdDeleteResponse, DeleteItemTypeItemtypeIdDeleteData, DeleteItemTypeItemtypeIdDeleteError, DeleteItemTypeItemtypeIdDeleteResponse, DeleteStrikeStrikeIdDeleteData, DeleteStrikeStrikeIdDeleteError, DeleteStrikeStrikeIdDeleteResponse, GetEventsEventGetData, GetItemItemIdGetData, GetItemsItemGetData, GetItemsTypesItemtypeGetData, GetItemTypeItemtypeIdGetData, GetMySessionsRentalSessionsUserMeGetData, GetRentalSessionRentalSessionsSessionIdGetData, GetRentalSessionsRentalSessionsGetData, GetStrikesStrikeGetData, GetUserStrikesStrikeUserUserIdGetData, MakeItemTypeAvailableItemtypeAvailableIdPatchData, MakeItemTypeAvailableItemtypeAvailableIdPatchError, MakeItemTypeAvailableItemtypeAvailableIdPatchResponse, StartRentalSessionRentalSessionsSessionIdStartPatchData, StartRentalSessionRentalSessionsSessionIdStartPatchError, StartRentalSessionRentalSessionsSessionIdStartPatchResponse, UpdateItemItemIdPatchData, UpdateItemItemIdPatchError, UpdateItemItemIdPatchResponse, UpdateItemTypeItemtypeIdPatchData, UpdateItemTypeItemtypeIdPatchError, UpdateItemTypeItemtypeIdPatchResponse, UpdateRentalSessionRentalSessionsSessionIdPatchData, UpdateRentalSessionRentalSessionsSessionIdPatchError, UpdateRentalSessionRentalSessionsSessionIdPatchResponse } from '../types.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? client).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const getEventsEventGetQueryKey = (options?: Options<GetEventsEventGetData>) => createQueryKey('getEventsEventGet', options);

/**
 * Get Events
 *
 * Retrieves a list of events, with optional filtering.
 *
 * Scopes: `["rental.event.view"]`
 *
 * - **admin_id**: Filter events by admin ID.
 * - **session_id**: Filter events by session ID.
 *
 * Returns a list of events.
 */
export const getEventsEventGetOptions = (options?: Options<GetEventsEventGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getEventsEventGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getEventsEventGetQueryKey(options)
    });
};

export const getItemsItemGetQueryKey = (options?: Options<GetItemsItemGetData>) => createQueryKey('getItemsItemGet', options);

/**
 * Get Items
 *
 * Retrieves a list of items. If `type_id` is specified, only items of that type are returned.
 *
 * - **type_id**: The ID of the item type (optional).
 *
 * Returns a list of items.
 */
export const getItemsItemGetOptions = (options?: Options<GetItemsItemGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getItemsItemGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getItemsItemGetQueryKey(options)
    });
};

/**
 * Create Item
 *
 * Creates a new item.
 *
 * Scopes: `["rental.item.create"]`
 *
 * - **item**: The data for the new item.
 *
 * Returns the created item.
 *
 * Raises **ObjectNotFound** if the item type with the specified `type_id` is not found.
 */
export const createItemItemPostMutation = (options?: Partial<Options<CreateItemItemPostData>>): UseMutationOptions<CreateItemItemPostResponse, CreateItemItemPostError, Options<CreateItemItemPostData>> => {
    const mutationOptions: UseMutationOptions<CreateItemItemPostResponse, CreateItemItemPostError, Options<CreateItemItemPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createItemItemPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Item
 *
 * Deletes an item by its ID.
 *
 * Scopes: `["rental.item.delete"]`
 *
 * - **id**: The ID of the item.
 *
 * Returns a status response.
 *
 * Raises **ObjectNotFound** if the item with the specified ID is not found.
 */
export const deleteItemItemIdDeleteMutation = (options?: Partial<Options<DeleteItemItemIdDeleteData>>): UseMutationOptions<DeleteItemItemIdDeleteResponse, DeleteItemItemIdDeleteError, Options<DeleteItemItemIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteItemItemIdDeleteResponse, DeleteItemItemIdDeleteError, Options<DeleteItemItemIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteItemItemIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getItemItemIdGetQueryKey = (options: Options<GetItemItemIdGetData>) => createQueryKey('getItemItemIdGet', options);

/**
 * Get Item
 *
 * Получает предмет по его идентификатору.
 */
export const getItemItemIdGetOptions = (options: Options<GetItemItemIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getItemItemIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getItemItemIdGetQueryKey(options)
    });
};

/**
 * Update Item
 *
 * Updates the availability status of an item by its ID.
 *
 * Scopes: `["rental.item.patch"]`
 *
 * - **id**: The ID of the item.
 * - **is_available**: The new availability status for the item.
 *
 * Returns the updated item.
 *
 * Raises **ObjectNotFound** if the item with the specified ID is not found.
 */
export const updateItemItemIdPatchMutation = (options?: Partial<Options<UpdateItemItemIdPatchData>>): UseMutationOptions<UpdateItemItemIdPatchResponse, UpdateItemItemIdPatchError, Options<UpdateItemItemIdPatchData>> => {
    const mutationOptions: UseMutationOptions<UpdateItemItemIdPatchResponse, UpdateItemItemIdPatchError, Options<UpdateItemItemIdPatchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateItemItemIdPatch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create Rental Session
 *
 * Создает новую сессию аренды для указанного типа предмета.
 *
 * Cкоупы: `["rental.session.create"]`
 *
 * :param item_type_id: Идентификатор типа предмета.
 * :raises NoneAvailable: Если нет доступных предметов указанного типа.
 * :raises SessionExists: Если у пользователя уже есть сессия с указанным типом предмета.
 */
export const createRentalSessionRentalSessionsItemTypeIdPostMutation = (options?: Partial<Options<CreateRentalSessionRentalSessionsItemTypeIdPostData>>): UseMutationOptions<CreateRentalSessionRentalSessionsItemTypeIdPostResponse, CreateRentalSessionRentalSessionsItemTypeIdPostError, Options<CreateRentalSessionRentalSessionsItemTypeIdPostData>> => {
    const mutationOptions: UseMutationOptions<CreateRentalSessionRentalSessionsItemTypeIdPostResponse, CreateRentalSessionRentalSessionsItemTypeIdPostError, Options<CreateRentalSessionRentalSessionsItemTypeIdPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createRentalSessionRentalSessionsItemTypeIdPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Start Rental Session
 *
 * Starts a rental session, changing its status to ACTIVE.
 *
 * Scopes: `["rental.session.admin"]`
 *
 * - **session_id**: The ID of the rental session to start.
 *
 * Returns the updated rental session.
 *
 * Raises **ObjectNotFound** if the session with the specified ID is not found.
 */
export const startRentalSessionRentalSessionsSessionIdStartPatchMutation = (options?: Partial<Options<StartRentalSessionRentalSessionsSessionIdStartPatchData>>): UseMutationOptions<StartRentalSessionRentalSessionsSessionIdStartPatchResponse, StartRentalSessionRentalSessionsSessionIdStartPatchError, Options<StartRentalSessionRentalSessionsSessionIdStartPatchData>> => {
    const mutationOptions: UseMutationOptions<StartRentalSessionRentalSessionsSessionIdStartPatchResponse, StartRentalSessionRentalSessionsSessionIdStartPatchError, Options<StartRentalSessionRentalSessionsSessionIdStartPatchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await startRentalSessionRentalSessionsSessionIdStartPatch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Accept End Rental Session
 *
 * Ends a rental session, changing its status to RETURNED. Issues a strike if specified.
 *
 * Scopes: `["rental.session.admin"]`
 *
 * - **session_id**: The ID of the rental session to end.
 * - **with_strike**: A flag indicating whether to issue a strike.
 * - **strike_reason**: The reason for the strike.
 *
 * Returns the updated rental session.
 *
 * Raises:
 * - **ObjectNotFound**: If the session with the specified ID is not found.
 * - **InactiveSession**: If the session is not active.
 */
export const acceptEndRentalSessionRentalSessionsSessionIdReturnPatchMutation = (options?: Partial<Options<AcceptEndRentalSessionRentalSessionsSessionIdReturnPatchData>>): UseMutationOptions<AcceptEndRentalSessionRentalSessionsSessionIdReturnPatchResponse, AcceptEndRentalSessionRentalSessionsSessionIdReturnPatchError, Options<AcceptEndRentalSessionRentalSessionsSessionIdReturnPatchData>> => {
    const mutationOptions: UseMutationOptions<AcceptEndRentalSessionRentalSessionsSessionIdReturnPatchResponse, AcceptEndRentalSessionRentalSessionsSessionIdReturnPatchError, Options<AcceptEndRentalSessionRentalSessionsSessionIdReturnPatchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await acceptEndRentalSessionRentalSessionsSessionIdReturnPatch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getRentalSessionRentalSessionsSessionIdGetQueryKey = (options: Options<GetRentalSessionRentalSessionsSessionIdGetData>) => createQueryKey('getRentalSessionRentalSessionsSessionIdGet', options);

/**
 * Get Rental Session
 */
export const getRentalSessionRentalSessionsSessionIdGetOptions = (options: Options<GetRentalSessionRentalSessionsSessionIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRentalSessionRentalSessionsSessionIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getRentalSessionRentalSessionsSessionIdGetQueryKey(options)
    });
};

/**
 * Update Rental Session
 *
 * Updates the information of a rental session.
 *
 * Scopes: `["rental.session.admin"]`
 *
 * - **session_id**: The ID of the rental session to update.
 * - **update_data**: The data to update the session with.
 *
 * Returns the updated rental session.
 *
 * Raises **ObjectNotFound** if the session with the specified ID is not found.
 */
export const updateRentalSessionRentalSessionsSessionIdPatchMutation = (options?: Partial<Options<UpdateRentalSessionRentalSessionsSessionIdPatchData>>): UseMutationOptions<UpdateRentalSessionRentalSessionsSessionIdPatchResponse, UpdateRentalSessionRentalSessionsSessionIdPatchError, Options<UpdateRentalSessionRentalSessionsSessionIdPatchData>> => {
    const mutationOptions: UseMutationOptions<UpdateRentalSessionRentalSessionsSessionIdPatchResponse, UpdateRentalSessionRentalSessionsSessionIdPatchError, Options<UpdateRentalSessionRentalSessionsSessionIdPatchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateRentalSessionRentalSessionsSessionIdPatch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getRentalSessionsRentalSessionsGetQueryKey = (options?: Options<GetRentalSessionsRentalSessionsGetData>) => createQueryKey('getRentalSessionsRentalSessionsGet', options);

/**
 * Get Rental Sessions
 *
 * Retrieves a list of rental sessions with optional status filtering.
 *
 * Scopes: `["rental.session.admin"]`
 *
 * - **is_reserved**: Filter by reserved sessions.
 * - **is_canceled**: Filter by canceled sessions.
 * - **is_dismissed**: Filter by dismissed sessions.
 * - **is_overdue**: Filter by overdue sessions.
 * - **is_returned**: Filter by returned sessions.
 * - **is_active**: Filter by active sessions.
 * - **is_expired**: Filter by expired sessions.
 * - **user_id**: User_id to get sessions
 * Returns a list of rental sessions.
 */
export const getRentalSessionsRentalSessionsGetOptions = (options?: Options<GetRentalSessionsRentalSessionsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRentalSessionsRentalSessionsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getRentalSessionsRentalSessionsGetQueryKey(options)
    });
};

export const getMySessionsRentalSessionsUserMeGetQueryKey = (options?: Options<GetMySessionsRentalSessionsUserMeGetData>) => createQueryKey('getMySessionsRentalSessionsUserMeGet', options);

/**
 * Get My Sessions
 *
 * Retrieves a list of rental sessions for the user with optional status filtering.
 *
 * - **is_reserved**: Filter by reserved sessions.
 * - **is_canceled**: Filter by canceled sessions.
 * - **is_dismissed**: Filter by dismissed sessions.
 * - **is_overdue**: Filter by overdue sessions.
 * - **is_returned**: Filter by returned sessions.
 * - **is_active**: Filter by active sessions.
 * - **is_expired**: Filter by expired sessions.
 * Returns a list of rental sessions.
 */
export const getMySessionsRentalSessionsUserMeGetOptions = (options?: Options<GetMySessionsRentalSessionsUserMeGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMySessionsRentalSessionsUserMeGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMySessionsRentalSessionsUserMeGetQueryKey(options)
    });
};

/**
 * Cancel Rental Session
 *
 * Cancels a session in the RESERVED status. Can only be canceled by the user who created it.
 *
 * - **session_id**: The ID of the rental session to cancel.
 *
 * Returns the canceled rental session.
 *
 * Raises **ForbiddenAction** if the user is not the owner or the session is not in RESERVED status.
 */
export const cancelRentalSessionRentalSessionsSessionIdCancelDeleteMutation = (options?: Partial<Options<CancelRentalSessionRentalSessionsSessionIdCancelDeleteData>>): UseMutationOptions<CancelRentalSessionRentalSessionsSessionIdCancelDeleteResponse, CancelRentalSessionRentalSessionsSessionIdCancelDeleteError, Options<CancelRentalSessionRentalSessionsSessionIdCancelDeleteData>> => {
    const mutationOptions: UseMutationOptions<CancelRentalSessionRentalSessionsSessionIdCancelDeleteResponse, CancelRentalSessionRentalSessionsSessionIdCancelDeleteError, Options<CancelRentalSessionRentalSessionsSessionIdCancelDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await cancelRentalSessionRentalSessionsSessionIdCancelDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Item Type
 *
 * Deletes an item type by its ID.
 *
 * Scopes: `["rental.item_type.delete"]`
 *
 * - **id**: The ID of the item type.
 *
 * Returns a status response.
 *
 * Raises **ObjectNotFound** if the item type with the specified ID is not found.
 *
 * Raises **ForbiddenAction** if the item type with the specified ID has items.
 */
export const deleteItemTypeItemtypeIdDeleteMutation = (options?: Partial<Options<DeleteItemTypeItemtypeIdDeleteData>>): UseMutationOptions<DeleteItemTypeItemtypeIdDeleteResponse, DeleteItemTypeItemtypeIdDeleteError, Options<DeleteItemTypeItemtypeIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteItemTypeItemtypeIdDeleteResponse, DeleteItemTypeItemtypeIdDeleteError, Options<DeleteItemTypeItemtypeIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteItemTypeItemtypeIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getItemTypeItemtypeIdGetQueryKey = (options: Options<GetItemTypeItemtypeIdGetData>) => createQueryKey('getItemTypeItemtypeIdGet', options);

/**
 * Get Item Type
 *
 * Retrieves information about an item type by its ID.
 *
 * - **id**: The ID of the item type.
 *
 * Returns the item type information.
 *
 * Raises **ObjectNotFound** if the item type with the specified ID is not found.
 */
export const getItemTypeItemtypeIdGetOptions = (options: Options<GetItemTypeItemtypeIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getItemTypeItemtypeIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getItemTypeItemtypeIdGetQueryKey(options)
    });
};

/**
 * Update Item Type
 *
 * Updates the information of an item type by its ID.
 *
 * Scopes: `["rental.item_type.update"]`
 *
 * - **id**: The ID of the item type.
 * - **item_type_info**: The data to update the item type with.
 *
 * Returns the updated item type.
 *
 * Raises **ObjectNotFound** if the item type with the specified ID is not found.
 */
export const updateItemTypeItemtypeIdPatchMutation = (options?: Partial<Options<UpdateItemTypeItemtypeIdPatchData>>): UseMutationOptions<UpdateItemTypeItemtypeIdPatchResponse, UpdateItemTypeItemtypeIdPatchError, Options<UpdateItemTypeItemtypeIdPatchData>> => {
    const mutationOptions: UseMutationOptions<UpdateItemTypeItemtypeIdPatchResponse, UpdateItemTypeItemtypeIdPatchError, Options<UpdateItemTypeItemtypeIdPatchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateItemTypeItemtypeIdPatch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getItemsTypesItemtypeGetQueryKey = (options?: Options<GetItemsTypesItemtypeGetData>) => createQueryKey('getItemsTypesItemtypeGet', options);

/**
 * Get Items Types
 *
 * Retrieves a list of all item types.
 *
 * Returns a list of all item types.
 *
 * Raises **ObjectNotFound** if no item types are found.
 */
export const getItemsTypesItemtypeGetOptions = (options?: Options<GetItemsTypesItemtypeGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getItemsTypesItemtypeGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getItemsTypesItemtypeGetQueryKey(options)
    });
};

/**
 * Create Item Type
 *
 * Creates a new item type.
 *
 * Scopes: `["rental.item_type.create"]`
 *
 * - **item_type_info**: The data for the new item type.
 *
 * Returns the created item type.
 */
export const createItemTypeItemtypePostMutation = (options?: Partial<Options<CreateItemTypeItemtypePostData>>): UseMutationOptions<CreateItemTypeItemtypePostResponse, CreateItemTypeItemtypePostError, Options<CreateItemTypeItemtypePostData>> => {
    const mutationOptions: UseMutationOptions<CreateItemTypeItemtypePostResponse, CreateItemTypeItemtypePostError, Options<CreateItemTypeItemtypePostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createItemTypeItemtypePost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Make Item Type Available
 *
 * Делает один предмет доступным по ID типа предмета.
 *
 * Скоупы: `["rental.item_type.update"]`
 *
 * - **id**: ID типа предмета.
 * - **count**: Абсолютное количество предметов, которые нужно сделать доступными.
 * Если доступных меньше, делает больше доступных. Если доступных больше, делает меньше доступных.
 * Если нет возможности сделать count доступных, делает доступным максимально возможное количество.
 * Возвращает id всех возвращенных предметов и их количество.
 *
 *
 *
 * Вызывает **ObjectNotFound**, если тип предмета с указанным ID не найден.
 */
export const makeItemTypeAvailableItemtypeAvailableIdPatchMutation = (options?: Partial<Options<MakeItemTypeAvailableItemtypeAvailableIdPatchData>>): UseMutationOptions<MakeItemTypeAvailableItemtypeAvailableIdPatchResponse, MakeItemTypeAvailableItemtypeAvailableIdPatchError, Options<MakeItemTypeAvailableItemtypeAvailableIdPatchData>> => {
    const mutationOptions: UseMutationOptions<MakeItemTypeAvailableItemtypeAvailableIdPatchResponse, MakeItemTypeAvailableItemtypeAvailableIdPatchError, Options<MakeItemTypeAvailableItemtypeAvailableIdPatchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await makeItemTypeAvailableItemtypeAvailableIdPatch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getStrikesStrikeGetQueryKey = (options?: Options<GetStrikesStrikeGetData>) => createQueryKey('getStrikesStrikeGet', options);

/**
 * Get Strikes
 *
 * Retrieves a list of strikes with optional filtering.
 *
 * Scopes: `["rental.strike.read"]`
 *
 * - **admin_id**: Filter strikes by admin ID.
 * - **session_id**: Filter strikes by session ID.
 * - **from_date**: Filter strikes created after this date.
 * - **to_date**: Filter strikes created before this date.
 *
 * Returns a list of strikes.
 *
 * Raises **DateRangeError** if only one of `from_date` or `to_date` is provided.
 */
export const getStrikesStrikeGetOptions = (options?: Options<GetStrikesStrikeGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getStrikesStrikeGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getStrikesStrikeGetQueryKey(options)
    });
};

/**
 * Create Strike
 *
 * Creates a new strike.
 *
 * Scopes: `["rental.strike.create"]`
 *
 * - **strike_info**: The data for the new strike.
 *
 * Returns the created strike.
 *
 * If session does not exist returns ObjectNotFound.
 */
export const createStrikeStrikePostMutation = (options?: Partial<Options<CreateStrikeStrikePostData>>): UseMutationOptions<CreateStrikeStrikePostResponse, CreateStrikeStrikePostError, Options<CreateStrikeStrikePostData>> => {
    const mutationOptions: UseMutationOptions<CreateStrikeStrikePostResponse, CreateStrikeStrikePostError, Options<CreateStrikeStrikePostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createStrikeStrikePost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUserStrikesStrikeUserUserIdGetQueryKey = (options: Options<GetUserStrikesStrikeUserUserIdGetData>) => createQueryKey('getUserStrikesStrikeUserUserIdGet', options);

/**
 * Get User Strikes
 *
 * Retrieves a list of strikes for a specific user.
 *
 * - **user_id**: The ID of the user.
 *
 * Returns a list of strikes.
 */
export const getUserStrikesStrikeUserUserIdGetOptions = (options: Options<GetUserStrikesStrikeUserUserIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserStrikesStrikeUserUserIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserStrikesStrikeUserUserIdGetQueryKey(options)
    });
};

/**
 * Delete Strike
 *
 * Deletes a strike by its ID.
 *
 * Scopes: `["rental.strike.delete"]`
 *
 * - **id**: The ID of the strike to delete.
 *
 * Returns a status response.
 *
 * Raises **ObjectNotFound** if the strike with the specified ID is not found.
 */
export const deleteStrikeStrikeIdDeleteMutation = (options?: Partial<Options<DeleteStrikeStrikeIdDeleteData>>): UseMutationOptions<DeleteStrikeStrikeIdDeleteResponse, DeleteStrikeStrikeIdDeleteError, Options<DeleteStrikeStrikeIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteStrikeStrikeIdDeleteResponse, DeleteStrikeStrikeIdDeleteError, Options<DeleteStrikeStrikeIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteStrikeStrikeIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

// This file is auto-generated by @hey-api/openapi-ts

import { type Client, type Options as Options2, type TDataShape, urlSearchParamsBodySerializer } from './client';
import { client } from './client.gen';
import type { ApproveEmailEmailApproveGetData, ApproveEmailEmailApproveGetErrors, ApproveEmailEmailApproveGetResponses, AuthUrlAuthenticAuthUrlGetData, AuthUrlAuthenticAuthUrlGetResponses, AuthUrlGithubAuthUrlGetData, AuthUrlGithubAuthUrlGetResponses, AuthUrlGoogleAuthUrlGetData, AuthUrlGoogleAuthUrlGetResponses, AuthUrlLkMsuAuthUrlGetData, AuthUrlLkMsuAuthUrlGetResponses, AuthUrlMyMsuAuthUrlGetData, AuthUrlMyMsuAuthUrlGetResponses, AuthUrlPhysicsMsuAuthUrlGetData, AuthUrlPhysicsMsuAuthUrlGetResponses, AuthUrlTelegramAuthUrlGetData, AuthUrlTelegramAuthUrlGetResponses, AuthUrlVkAuthUrlGetData, AuthUrlVkAuthUrlGetResponses, AuthUrlYandexAuthUrlGetData, AuthUrlYandexAuthUrlGetResponses, CreateGroupGroupPostData, CreateGroupGroupPostErrors, CreateGroupGroupPostResponses, CreateScopeScopePostData, CreateScopeScopePostErrors, CreateScopeScopePostResponses, CreateSessionSessionPostData, CreateSessionSessionPostErrors, CreateSessionSessionPostResponses, DeleteGroupGroupIdDeleteData, DeleteGroupGroupIdDeleteErrors, DeleteGroupGroupIdDeleteResponses, DeleteScopeScopeIdDeleteData, DeleteScopeScopeIdDeleteErrors, DeleteScopeScopeIdDeleteResponses, DeleteSessionSessionTokenDeleteData, DeleteSessionSessionTokenDeleteErrors, DeleteSessionSessionTokenDeleteResponses, DeleteSessionsSessionDeleteData, DeleteSessionsSessionDeleteErrors, DeleteSessionsSessionDeleteResponses, DeleteUserUserUserIdDeleteData, DeleteUserUserUserIdDeleteErrors, DeleteUserUserUserIdDeleteResponses, GetGroupGroupIdGetData, GetGroupGroupIdGetErrors, GetGroupGroupIdGetResponses, GetGroupsGroupGetData, GetGroupsGroupGetErrors, GetGroupsGroupGetResponses, GetLinkAirflowUserIdLinkGetData, GetLinkAirflowUserIdLinkGetErrors, GetLinkAirflowUserIdLinkGetResponses, GetLinkCoderUserIdLinkGetData, GetLinkCoderUserIdLinkGetErrors, GetLinkCoderUserIdLinkGetResponses, GetLinkMailuUserIdLinkGetData, GetLinkMailuUserIdLinkGetErrors, GetLinkMailuUserIdLinkGetResponses, GetLinkPostgresUserIdLinkGetData, GetLinkPostgresUserIdLinkGetErrors, GetLinkPostgresUserIdLinkGetResponses, GetScopeScopeIdGetData, GetScopeScopeIdGetErrors, GetScopeScopeIdGetResponses, GetScopesScopeGetData, GetScopesScopeGetResponses, GetSessionsSessionGetData, GetSessionsSessionGetErrors, GetSessionsSessionGetResponses, GetUsersUserGetData, GetUsersUserGetErrors, GetUsersUserGetResponses, GetUserUserUserIdGetData, GetUserUserUserIdGetErrors, GetUserUserUserIdGetResponses, JwksOpenidWellKnownJwksGetData, JwksOpenidWellKnownJwksGetResponses, LinkAirflowUserIdLinkPostData, LinkAirflowUserIdLinkPostErrors, LinkAirflowUserIdLinkPostResponses, LinkCoderUserIdLinkPostData, LinkCoderUserIdLinkPostErrors, LinkCoderUserIdLinkPostResponses, LinkMailuUserIdLinkPostData, LinkMailuUserIdLinkPostErrors, LinkMailuUserIdLinkPostResponses, LinkPostgresUserIdLinkPostData, LinkPostgresUserIdLinkPostErrors, LinkPostgresUserIdLinkPostResponses, LoginAuthenticLoginPostData, LoginAuthenticLoginPostErrors, LoginAuthenticLoginPostResponses, LoginEmailLoginPostData, LoginEmailLoginPostErrors, LoginEmailLoginPostResponses, LoginGithubLoginPostData, LoginGithubLoginPostErrors, LoginGithubLoginPostResponses, LoginGoogleLoginPostData, LoginGoogleLoginPostErrors, LoginGoogleLoginPostResponses, LoginLkMsuLoginPostData, LoginLkMsuLoginPostErrors, LoginLkMsuLoginPostResponses, LoginMyMsuLoginPostData, LoginMyMsuLoginPostErrors, LoginMyMsuLoginPostResponses, LoginPhysicsMsuLoginPostData, LoginPhysicsMsuLoginPostErrors, LoginPhysicsMsuLoginPostResponses, LoginTelegramLoginPostData, LoginTelegramLoginPostErrors, LoginTelegramLoginPostResponses, LoginVkLoginPostData, LoginVkLoginPostErrors, LoginVkLoginPostResponses, LoginYandexLoginPostData, LoginYandexLoginPostErrors, LoginYandexLoginPostResponses, LogoutLogoutPostData, LogoutLogoutPostResponses, MeMeGetData, MeMeGetErrors, MeMeGetResponses, OpenidConfigurationOpenidWellKnownOpenidConfigurationGetData, OpenidConfigurationOpenidWellKnownOpenidConfigurationGetResponses, PatchGroupGroupIdPatchData, PatchGroupGroupIdPatchErrors, PatchGroupGroupIdPatchResponses, PatchUserUserUserIdPatchData, PatchUserUserUserIdPatchErrors, PatchUserUserUserIdPatchResponses, RedirectUrlAuthenticRedirectUrlGetData, RedirectUrlAuthenticRedirectUrlGetResponses, RedirectUrlGithubRedirectUrlGetData, RedirectUrlGithubRedirectUrlGetResponses, RedirectUrlGoogleRedirectUrlGetData, RedirectUrlGoogleRedirectUrlGetResponses, RedirectUrlLkMsuRedirectUrlGetData, RedirectUrlLkMsuRedirectUrlGetResponses, RedirectUrlMyMsuRedirectUrlGetData, RedirectUrlMyMsuRedirectUrlGetResponses, RedirectUrlPhysicsMsuRedirectUrlGetData, RedirectUrlPhysicsMsuRedirectUrlGetResponses, RedirectUrlTelegramRedirectUrlGetData, RedirectUrlTelegramRedirectUrlGetResponses, RedirectUrlVkRedirectUrlGetData, RedirectUrlVkRedirectUrlGetResponses, RedirectUrlYandexRedirectUrlGetData, RedirectUrlYandexRedirectUrlGetResponses, RegisterAuthenticRegistrationPostData, RegisterAuthenticRegistrationPostErrors, RegisterAuthenticRegistrationPostResponses, RegisterEmailRegistrationPostData, RegisterEmailRegistrationPostErrors, RegisterEmailRegistrationPostResponses, RegisterGithubRegistrationPostData, RegisterGithubRegistrationPostErrors, RegisterGithubRegistrationPostResponses, RegisterGoogleRegistrationPostData, RegisterGoogleRegistrationPostErrors, RegisterGoogleRegistrationPostResponses, RegisterLkMsuRegistrationPostData, RegisterLkMsuRegistrationPostErrors, RegisterLkMsuRegistrationPostResponses, RegisterMyMsuRegistrationPostData, RegisterMyMsuRegistrationPostErrors, RegisterMyMsuRegistrationPostResponses, RegisterPhysicsMsuRegistrationPostData, RegisterPhysicsMsuRegistrationPostErrors, RegisterPhysicsMsuRegistrationPostResponses, RegisterTelegramRegistrationPostData, RegisterTelegramRegistrationPostErrors, RegisterTelegramRegistrationPostResponses, RegisterVkRegistrationPostData, RegisterVkRegistrationPostErrors, RegisterVkRegistrationPostResponses, RegisterYandexRegistrationPostData, RegisterYandexRegistrationPostErrors, RegisterYandexRegistrationPostResponses, RequestResetEmailEmailResetEmailRequestPostData, RequestResetEmailEmailResetEmailRequestPostErrors, RequestResetEmailEmailResetEmailRequestPostResponses, RequestResetForgottenPasswordEmailResetPasswordRestorePostData, RequestResetForgottenPasswordEmailResetPasswordRestorePostErrors, RequestResetForgottenPasswordEmailResetPasswordRestorePostResponses, RequestResetPasswordEmailResetPasswordRequestPostData, RequestResetPasswordEmailResetPasswordRequestPostErrors, RequestResetPasswordEmailResetPasswordRequestPostResponses, ResetEmailEmailResetEmailGetData, ResetEmailEmailResetEmailGetErrors, ResetEmailEmailResetEmailGetResponses, ResetForgottenPasswordEmailResetPasswordPostData, ResetForgottenPasswordEmailResetPasswordPostErrors, ResetForgottenPasswordEmailResetPasswordPostResponses, TokenOpenidTokenPostData, TokenOpenidTokenPostErrors, TokenOpenidTokenPostResponses, UnlinkAirflowUserIdLinkDeleteData, UnlinkAirflowUserIdLinkDeleteErrors, UnlinkAirflowUserIdLinkDeleteResponses, UnlinkCoderUserIdLinkDeleteData, UnlinkCoderUserIdLinkDeleteErrors, UnlinkCoderUserIdLinkDeleteResponses, UnlinkMailuUserIdLinkDeleteData, UnlinkMailuUserIdLinkDeleteErrors, UnlinkMailuUserIdLinkDeleteResponses, UnlinkPostgresUserIdLinkDeleteData, UnlinkPostgresUserIdLinkDeleteErrors, UnlinkPostgresUserIdLinkDeleteResponses, UnregisterAuthenticDeleteData, UnregisterAuthenticDeleteResponses, UnregisterGithubDeleteData, UnregisterGithubDeleteResponses, UnregisterGoogleDeleteData, UnregisterGoogleDeleteResponses, UnregisterLkMsuDeleteData, UnregisterLkMsuDeleteResponses, UnregisterMyMsuDeleteData, UnregisterMyMsuDeleteResponses, UnregisterPhysicsMsuDeleteData, UnregisterPhysicsMsuDeleteResponses, UnregisterTelegramDeleteData, UnregisterTelegramDeleteResponses, UnregisterVkDeleteData, UnregisterVkDeleteResponses, UnregisterYandexDeleteData, UnregisterYandexDeleteResponses, UpdateScopeScopeIdPatchData, UpdateScopeScopeIdPatchErrors, UpdateScopeScopeIdPatchResponses, UpdateSessionSessionIdPatchData, UpdateSessionSessionIdPatchErrors, UpdateSessionSessionIdPatchResponses } from './types.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = Options2<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Delete Group
 *
 * Scopes: `["auth.scope.delete"]`
 */
export const deleteGroupGroupIdDelete = <ThrowOnError extends boolean = false>(options: Options<DeleteGroupGroupIdDeleteData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteGroupGroupIdDeleteResponses, DeleteGroupGroupIdDeleteErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/group/{id}',
        ...options
    });
};

/**
 * Get Group
 *
 * Scopes: `["auth.group.read"]`
 */
export const getGroupGroupIdGet = <ThrowOnError extends boolean = false>(options: Options<GetGroupGroupIdGetData, ThrowOnError>) => {
    return (options.client ?? client).get<GetGroupGroupIdGetResponses, GetGroupGroupIdGetErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/group/{id}',
        ...options
    });
};

/**
 * Patch Group
 *
 * Scopes: `["auth.group.update"]`
 */
export const patchGroupGroupIdPatch = <ThrowOnError extends boolean = false>(options: Options<PatchGroupGroupIdPatchData, ThrowOnError>) => {
    return (options.client ?? client).patch<PatchGroupGroupIdPatchResponses, PatchGroupGroupIdPatchErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/group/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get Groups
 *
 * Scopes: `["auth.group.read"]`
 */
export const getGroupsGroupGet = <ThrowOnError extends boolean = false>(options?: Options<GetGroupsGroupGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetGroupsGroupGetResponses, GetGroupsGroupGetErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/group',
        ...options
    });
};

/**
 * Create Group
 *
 * Scopes: `["auth.group.create"]`
 */
export const createGroupGroupPost = <ThrowOnError extends boolean = false>(options: Options<CreateGroupGroupPostData, ThrowOnError>) => {
    return (options.client ?? client).post<CreateGroupGroupPostResponses, CreateGroupGroupPostErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/group',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get Scopes
 *
 * Scopes: `["auth.scope.read"]`
 */
export const getScopesScopeGet = <ThrowOnError extends boolean = false>(options?: Options<GetScopesScopeGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetScopesScopeGetResponses, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/scope',
        ...options
    });
};

/**
 * Create Scope
 *
 * Scopes: `["auth.scope.create"]`
 */
export const createScopeScopePost = <ThrowOnError extends boolean = false>(options: Options<CreateScopeScopePostData, ThrowOnError>) => {
    return (options.client ?? client).post<CreateScopeScopePostResponses, CreateScopeScopePostErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/scope',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete Scope
 *
 * Scopes: `["auth.scope.delete"]`
 */
export const deleteScopeScopeIdDelete = <ThrowOnError extends boolean = false>(options: Options<DeleteScopeScopeIdDeleteData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteScopeScopeIdDeleteResponses, DeleteScopeScopeIdDeleteErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/scope/{id}',
        ...options
    });
};

/**
 * Get Scope
 *
 * Scopes: `["auth.scope.read"]`
 */
export const getScopeScopeIdGet = <ThrowOnError extends boolean = false>(options: Options<GetScopeScopeIdGetData, ThrowOnError>) => {
    return (options.client ?? client).get<GetScopeScopeIdGetResponses, GetScopeScopeIdGetErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/scope/{id}',
        ...options
    });
};

/**
 * Update Scope
 *
 * Scopes: `["auth.scope.update"]`
 */
export const updateScopeScopeIdPatch = <ThrowOnError extends boolean = false>(options: Options<UpdateScopeScopeIdPatchData, ThrowOnError>) => {
    return (options.client ?? client).patch<UpdateScopeScopeIdPatchResponses, UpdateScopeScopeIdPatchErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/scope/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete User
 *
 * Scopes: `["auth.user.delete"]` or `["auth.user.selfdelete"]` for self delete
 */
export const deleteUserUserUserIdDelete = <ThrowOnError extends boolean = false>(options: Options<DeleteUserUserUserIdDeleteData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteUserUserUserIdDeleteResponses, DeleteUserUserUserIdDeleteErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/user/{user_id}',
        ...options
    });
};

/**
 * Get User
 *
 * Scopes: `["auth.user.read"]`
 */
export const getUserUserUserIdGet = <ThrowOnError extends boolean = false>(options: Options<GetUserUserUserIdGetData, ThrowOnError>) => {
    return (options.client ?? client).get<GetUserUserUserIdGetResponses, GetUserUserUserIdGetErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/user/{user_id}',
        ...options
    });
};

/**
 * Patch User
 *
 * Scopes: `["auth.user.update"]`
 */
export const patchUserUserUserIdPatch = <ThrowOnError extends boolean = false>(options: Options<PatchUserUserUserIdPatchData, ThrowOnError>) => {
    return (options.client ?? client).patch<PatchUserUserUserIdPatchResponses, PatchUserUserUserIdPatchErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/user/{user_id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get Users
 *
 * Scopes: `["auth.user.read"]`
 */
export const getUsersUserGet = <ThrowOnError extends boolean = false>(options?: Options<GetUsersUserGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetUsersUserGetResponses, GetUsersUserGetErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/user',
        ...options
    });
};

/**
 * Logout
 */
export const logoutLogoutPost = <ThrowOnError extends boolean = false>(options?: Options<LogoutLogoutPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<LogoutLogoutPostResponses, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/logout',
        ...options
    });
};

/**
 * Me
 */
export const meMeGet = <ThrowOnError extends boolean = false>(options?: Options<MeMeGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<MeMeGetResponses, MeMeGetErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/me',
        ...options
    });
};

/**
 * Delete Sessions
 */
export const deleteSessionsSessionDelete = <ThrowOnError extends boolean = false>(options?: Options<DeleteSessionsSessionDeleteData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteSessionsSessionDeleteResponses, DeleteSessionsSessionDeleteErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/session',
        ...options
    });
};

/**
 * Get Sessions
 */
export const getSessionsSessionGet = <ThrowOnError extends boolean = false>(options?: Options<GetSessionsSessionGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetSessionsSessionGetResponses, GetSessionsSessionGetErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/session',
        ...options
    });
};

/**
 * Create Session
 */
export const createSessionSessionPost = <ThrowOnError extends boolean = false>(options: Options<CreateSessionSessionPostData, ThrowOnError>) => {
    return (options.client ?? client).post<CreateSessionSessionPostResponses, CreateSessionSessionPostErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/session',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete Session
 */
export const deleteSessionSessionTokenDelete = <ThrowOnError extends boolean = false>(options: Options<DeleteSessionSessionTokenDeleteData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteSessionSessionTokenDeleteResponses, DeleteSessionSessionTokenDeleteErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/session/{token}',
        ...options
    });
};

/**
 * Update Session
 */
export const updateSessionSessionIdPatch = <ThrowOnError extends boolean = false>(options: Options<UpdateSessionSessionIdPatchData, ThrowOnError>) => {
    return (options.client ?? client).patch<UpdateSessionSessionIdPatchResponses, UpdateSessionSessionIdPatchErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/session/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Openid Configuration
 *
 * Конфигурация для подключения OpenID Connect совместимых приложений
 *
 * **Attention:** ручка соответствует спецификации не полностью, не все OIDC приложения смогут ей пользоваться
 */
export const openidConfigurationOpenidWellKnownOpenidConfigurationGet = <ThrowOnError extends boolean = false>(options?: Options<OpenidConfigurationOpenidWellKnownOpenidConfigurationGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<OpenidConfigurationOpenidWellKnownOpenidConfigurationGetResponses, unknown, ThrowOnError>({
        url: '/openid/.well_known/openid_configuration',
        ...options
    });
};

/**
 * Jwks
 *
 * Публичные ключи для проверки JWT токенов
 */
export const jwksOpenidWellKnownJwksGet = <ThrowOnError extends boolean = false>(options?: Options<JwksOpenidWellKnownJwksGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<JwksOpenidWellKnownJwksGetResponses, unknown, ThrowOnError>({
        url: '/openid/.well_known/jwks',
        ...options
    });
};

/**
 * Token
 *
 * Ручка для получения токена доступа
 *
 * ## Позволяет
 * - Обменять старый не-JWT токен на новый c таким же набором доступов и таким же сроком давности
 * - Обменять JWT токен на новый, если у него есть SESSION_UPDATE_SCOPE
 *
 * Потенциально будет позволять:
 * - Обменивать Refresh Token на пару Access Token + Refresh Token
 * - Обменивать Code (см. Oauth Authorization Code Flow) на пару Access Token + Refresh Token
 *
 * ## Параметры:
 * Для всех запросов
 * - `grant_type` – refresh_token/client_credentials (см. список в `/.well_known/openid_configuration` в поле `grant_types_supported`)
 * - `client_id` – строка, по которой проверяется принадлежность к проекту (сейчас только app)
 * - `scopes` – список прав для нового токена
 *
 * ### `grant_type=refresh_token`
 * - refresh_token – токен, выданный этой ручкой или ручкой `/login` в методе авторизации
 *
 * ### `grant_type=client_credentials`
 * - `username` – логин пользователя
 * - `password` – пароль пользователя
 */
export const tokenOpenidTokenPost = <ThrowOnError extends boolean = false>(options: Options<TokenOpenidTokenPostData, ThrowOnError>) => {
    return (options.client ?? client).post<TokenOpenidTokenPostResponses, TokenOpenidTokenPostErrors, ThrowOnError>({
        ...urlSearchParamsBodySerializer,
        url: '/openid/token',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options.headers
        }
    });
};

/**
 *  Unlink
 *
 * Отвязать внешний аккаунт пользователю
 *
 * Удалить данные может администратор
 */
export const unlinkAirflowUserIdLinkDelete = <ThrowOnError extends boolean = false>(options: Options<UnlinkAirflowUserIdLinkDeleteData, ThrowOnError>) => {
    return (options.client ?? client).delete<UnlinkAirflowUserIdLinkDeleteResponses, UnlinkAirflowUserIdLinkDeleteErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/airflow/{user_id}/link',
        ...options
    });
};

/**
 *  Get Link
 *
 * Получить данные внешнего аккаунт пользователя
 *
 * Получить данные может администратор или сам пользователь
 */
export const getLinkAirflowUserIdLinkGet = <ThrowOnError extends boolean = false>(options: Options<GetLinkAirflowUserIdLinkGetData, ThrowOnError>) => {
    return (options.client ?? client).get<GetLinkAirflowUserIdLinkGetResponses, GetLinkAirflowUserIdLinkGetErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/airflow/{user_id}/link',
        ...options
    });
};

/**
 *  Link
 *
 * Привязать пользователю внешний аккаунт
 *
 * Привязать аккаунт может только администратор
 */
export const linkAirflowUserIdLinkPost = <ThrowOnError extends boolean = false>(options: Options<LinkAirflowUserIdLinkPostData, ThrowOnError>) => {
    return (options.client ?? client).post<LinkAirflowUserIdLinkPostResponses, LinkAirflowUserIdLinkPostErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/airflow/{user_id}/link',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 *  Register
 *
 * Создает аккаунт или привязывает существующий
 */
export const registerAuthenticRegistrationPost = <ThrowOnError extends boolean = false>(options: Options<RegisterAuthenticRegistrationPostData, ThrowOnError>) => {
    return (options.client ?? client).post<RegisterAuthenticRegistrationPostResponses, RegisterAuthenticRegistrationPostErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/authentic/registration',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 *  Login
 *
 * Вход в пользователя с помощью аккаунта Authentic
 */
export const loginAuthenticLoginPost = <ThrowOnError extends boolean = false>(options: Options<LoginAuthenticLoginPostData, ThrowOnError>) => {
    return (options.client ?? client).post<LoginAuthenticLoginPostResponses, LoginAuthenticLoginPostErrors, ThrowOnError>({
        url: '/authentic/login',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 *  Redirect Url
 *
 * URL на который происходит редирект после завершения входа на стороне провайдера
 */
export const redirectUrlAuthenticRedirectUrlGet = <ThrowOnError extends boolean = false>(options?: Options<RedirectUrlAuthenticRedirectUrlGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<RedirectUrlAuthenticRedirectUrlGetResponses, unknown, ThrowOnError>({
        url: '/authentic/redirect_url',
        ...options
    });
};

/**
 *  Auth Url
 *
 * URL на который происходит редирект из приложения для авторизации на стороне провайдера
 */
export const authUrlAuthenticAuthUrlGet = <ThrowOnError extends boolean = false>(options?: Options<AuthUrlAuthenticAuthUrlGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<AuthUrlAuthenticAuthUrlGetResponses, unknown, ThrowOnError>({
        url: '/authentic/auth_url',
        ...options
    });
};

/**
 *  Unregister
 *
 * Отключает для пользователя метод входа
 */
export const unregisterAuthenticDelete = <ThrowOnError extends boolean = false>(options?: Options<UnregisterAuthenticDeleteData, ThrowOnError>) => {
    return (options?.client ?? client).delete<UnregisterAuthenticDeleteResponses, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/authentic',
        ...options
    });
};

/**
 *  Unlink
 *
 * Отвязать внешний аккаунт пользователю
 *
 * Удалить данные может администратор
 */
export const unlinkCoderUserIdLinkDelete = <ThrowOnError extends boolean = false>(options: Options<UnlinkCoderUserIdLinkDeleteData, ThrowOnError>) => {
    return (options.client ?? client).delete<UnlinkCoderUserIdLinkDeleteResponses, UnlinkCoderUserIdLinkDeleteErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/coder/{user_id}/link',
        ...options
    });
};

/**
 *  Get Link
 *
 * Получить данные внешнего аккаунт пользователя
 *
 * Получить данные может администратор или сам пользователь
 */
export const getLinkCoderUserIdLinkGet = <ThrowOnError extends boolean = false>(options: Options<GetLinkCoderUserIdLinkGetData, ThrowOnError>) => {
    return (options.client ?? client).get<GetLinkCoderUserIdLinkGetResponses, GetLinkCoderUserIdLinkGetErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/coder/{user_id}/link',
        ...options
    });
};

/**
 *  Link
 *
 * Привязать пользователю внешний аккаунт
 *
 * Привязать аккаунт может только администратор
 */
export const linkCoderUserIdLinkPost = <ThrowOnError extends boolean = false>(options: Options<LinkCoderUserIdLinkPostData, ThrowOnError>) => {
    return (options.client ?? client).post<LinkCoderUserIdLinkPostResponses, LinkCoderUserIdLinkPostErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/coder/{user_id}/link',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 *  Register
 */
export const registerEmailRegistrationPost = <ThrowOnError extends boolean = false>(options: Options<RegisterEmailRegistrationPostData, ThrowOnError>) => {
    return (options.client ?? client).post<RegisterEmailRegistrationPostResponses, RegisterEmailRegistrationPostErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/email/registration',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 *  Login
 */
export const loginEmailLoginPost = <ThrowOnError extends boolean = false>(options: Options<LoginEmailLoginPostData, ThrowOnError>) => {
    return (options.client ?? client).post<LoginEmailLoginPostResponses, LoginEmailLoginPostErrors, ThrowOnError>({
        url: '/email/login',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 *  Approve Email
 */
export const approveEmailEmailApproveGet = <ThrowOnError extends boolean = false>(options: Options<ApproveEmailEmailApproveGetData, ThrowOnError>) => {
    return (options.client ?? client).get<ApproveEmailEmailApproveGetResponses, ApproveEmailEmailApproveGetErrors, ThrowOnError>({
        url: '/email/approve',
        ...options
    });
};

/**
 *  Request Reset Email
 */
export const requestResetEmailEmailResetEmailRequestPost = <ThrowOnError extends boolean = false>(options: Options<RequestResetEmailEmailResetEmailRequestPostData, ThrowOnError>) => {
    return (options.client ?? client).post<RequestResetEmailEmailResetEmailRequestPostResponses, RequestResetEmailEmailResetEmailRequestPostErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/email/reset/email/request',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 *  Reset Email
 */
export const resetEmailEmailResetEmailGet = <ThrowOnError extends boolean = false>(options: Options<ResetEmailEmailResetEmailGetData, ThrowOnError>) => {
    return (options.client ?? client).get<ResetEmailEmailResetEmailGetResponses, ResetEmailEmailResetEmailGetErrors, ThrowOnError>({
        url: '/email/reset/email',
        ...options
    });
};

/**
 *  Request Reset Password
 */
export const requestResetPasswordEmailResetPasswordRequestPost = <ThrowOnError extends boolean = false>(options: Options<RequestResetPasswordEmailResetPasswordRequestPostData, ThrowOnError>) => {
    return (options.client ?? client).post<RequestResetPasswordEmailResetPasswordRequestPostResponses, RequestResetPasswordEmailResetPasswordRequestPostErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/email/reset/password/request',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 *  Request Reset Forgotten Password
 */
export const requestResetForgottenPasswordEmailResetPasswordRestorePost = <ThrowOnError extends boolean = false>(options: Options<RequestResetForgottenPasswordEmailResetPasswordRestorePostData, ThrowOnError>) => {
    return (options.client ?? client).post<RequestResetForgottenPasswordEmailResetPasswordRestorePostResponses, RequestResetForgottenPasswordEmailResetPasswordRestorePostErrors, ThrowOnError>({
        url: '/email/reset/password/restore',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 *  Reset Forgotten Password
 */
export const resetForgottenPasswordEmailResetPasswordPost = <ThrowOnError extends boolean = false>(options: Options<ResetForgottenPasswordEmailResetPasswordPostData, ThrowOnError>) => {
    return (options.client ?? client).post<ResetForgottenPasswordEmailResetPasswordPostResponses, ResetForgottenPasswordEmailResetPasswordPostErrors, ThrowOnError>({
        url: '/email/reset/password',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 *  Register
 *
 * Создает аккаунт или привязывает существующий
 *
 * Если передана активная сессия пользователя, то привязывает аккаунт https://github.com к
 * аккаунту в активной сессии. Иначе, создает новый пользователь и делает https://github.com
 * первым методом входа.
 */
export const registerGithubRegistrationPost = <ThrowOnError extends boolean = false>(options: Options<RegisterGithubRegistrationPostData, ThrowOnError>) => {
    return (options.client ?? client).post<RegisterGithubRegistrationPostResponses, RegisterGithubRegistrationPostErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/github/registration',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 *  Login
 *
 * Вход в пользователя с помощью аккаунта https://github.com
 *
 * Производит вход, если находит пользователя по уникальному идендификатору. Если аккаунт не
 * найден, возвращает ошибка.
 */
export const loginGithubLoginPost = <ThrowOnError extends boolean = false>(options: Options<LoginGithubLoginPostData, ThrowOnError>) => {
    return (options.client ?? client).post<LoginGithubLoginPostResponses, LoginGithubLoginPostErrors, ThrowOnError>({
        url: '/github/login',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 *  Redirect Url
 *
 * URL на который происходит редирект после завершения входа на стороне провайдера
 */
export const redirectUrlGithubRedirectUrlGet = <ThrowOnError extends boolean = false>(options?: Options<RedirectUrlGithubRedirectUrlGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<RedirectUrlGithubRedirectUrlGetResponses, unknown, ThrowOnError>({
        url: '/github/redirect_url',
        ...options
    });
};

/**
 *  Auth Url
 *
 * URL на который происходит редирект из приложения для авторизации на стороне провайдера
 */
export const authUrlGithubAuthUrlGet = <ThrowOnError extends boolean = false>(options?: Options<AuthUrlGithubAuthUrlGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<AuthUrlGithubAuthUrlGetResponses, unknown, ThrowOnError>({
        url: '/github/auth_url',
        ...options
    });
};

/**
 *  Unregister
 *
 * Отключает для пользователя метод входа
 */
export const unregisterGithubDelete = <ThrowOnError extends boolean = false>(options?: Options<UnregisterGithubDeleteData, ThrowOnError>) => {
    return (options?.client ?? client).delete<UnregisterGithubDeleteResponses, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/github',
        ...options
    });
};

/**
 *  Register
 *
 * Создает аккаунт или привязывает существующий
 *
 * Если передана активная сессия пользователя, то привязывает аккаунт Google к аккаунту в
 * активной сессии. иначе, создает новый пользователь и делает Google первым методом входа.
 */
export const registerGoogleRegistrationPost = <ThrowOnError extends boolean = false>(options: Options<RegisterGoogleRegistrationPostData, ThrowOnError>) => {
    return (options.client ?? client).post<RegisterGoogleRegistrationPostResponses, RegisterGoogleRegistrationPostErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/google/registration',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 *  Login
 *
 * Вход в пользователя с помощью аккаунта Google
 *
 * Производит вход, если находит пользователя по Google client_id. Если аккаунт не найден,
 * возвращает ошибка.
 */
export const loginGoogleLoginPost = <ThrowOnError extends boolean = false>(options: Options<LoginGoogleLoginPostData, ThrowOnError>) => {
    return (options.client ?? client).post<LoginGoogleLoginPostResponses, LoginGoogleLoginPostErrors, ThrowOnError>({
        url: '/google/login',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 *  Redirect Url
 *
 * URL на который происходит редирект после завершения входа на стороне провайдера
 */
export const redirectUrlGoogleRedirectUrlGet = <ThrowOnError extends boolean = false>(options?: Options<RedirectUrlGoogleRedirectUrlGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<RedirectUrlGoogleRedirectUrlGetResponses, unknown, ThrowOnError>({
        url: '/google/redirect_url',
        ...options
    });
};

/**
 *  Auth Url
 *
 * URL на который происходит редирект из приложения для авторизации на стороне провайдера
 */
export const authUrlGoogleAuthUrlGet = <ThrowOnError extends boolean = false>(options?: Options<AuthUrlGoogleAuthUrlGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<AuthUrlGoogleAuthUrlGetResponses, unknown, ThrowOnError>({
        url: '/google/auth_url',
        ...options
    });
};

/**
 *  Unregister
 *
 * Отключает для пользователя метод входа
 */
export const unregisterGoogleDelete = <ThrowOnError extends boolean = false>(options?: Options<UnregisterGoogleDeleteData, ThrowOnError>) => {
    return (options?.client ?? client).delete<UnregisterGoogleDeleteResponses, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/google',
        ...options
    });
};

/**
 *  Register
 *
 * Создает аккаунт или привязывает существующий
 *
 * Если передана активная сессия пользователя, то привязывает аккаунт https://lk.msu.ru к
 * аккаунту в активной сессии. Иначе, создает новый пользователь и делает https://lk.msu.ru
 * первым методом входа.
 */
export const registerLkMsuRegistrationPost = <ThrowOnError extends boolean = false>(options: Options<RegisterLkMsuRegistrationPostData, ThrowOnError>) => {
    return (options.client ?? client).post<RegisterLkMsuRegistrationPostResponses, RegisterLkMsuRegistrationPostErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/lk-msu/registration',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 *  Login
 *
 * Вход в пользователя с помощью аккаунта https://lk.msu.ru
 *
 * Производит вход, если находит пользователя по уникальному идендификатору. Если аккаунт не
 * найден, возвращает ошибка.
 */
export const loginLkMsuLoginPost = <ThrowOnError extends boolean = false>(options: Options<LoginLkMsuLoginPostData, ThrowOnError>) => {
    return (options.client ?? client).post<LoginLkMsuLoginPostResponses, LoginLkMsuLoginPostErrors, ThrowOnError>({
        url: '/lk-msu/login',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 *  Redirect Url
 *
 * URL на который происходит редирект после завершения входа на стороне провайдера
 */
export const redirectUrlLkMsuRedirectUrlGet = <ThrowOnError extends boolean = false>(options?: Options<RedirectUrlLkMsuRedirectUrlGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<RedirectUrlLkMsuRedirectUrlGetResponses, unknown, ThrowOnError>({
        url: '/lk-msu/redirect_url',
        ...options
    });
};

/**
 *  Auth Url
 *
 * URL на который происходит редирект из приложения для авторизации на стороне провайдера
 */
export const authUrlLkMsuAuthUrlGet = <ThrowOnError extends boolean = false>(options?: Options<AuthUrlLkMsuAuthUrlGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<AuthUrlLkMsuAuthUrlGetResponses, unknown, ThrowOnError>({
        url: '/lk-msu/auth_url',
        ...options
    });
};

/**
 *  Unregister
 *
 * Отключает для пользователя метод входа
 */
export const unregisterLkMsuDelete = <ThrowOnError extends boolean = false>(options?: Options<UnregisterLkMsuDeleteData, ThrowOnError>) => {
    return (options?.client ?? client).delete<UnregisterLkMsuDeleteResponses, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/lk-msu',
        ...options
    });
};

/**
 *  Unlink
 *
 * Отвязать внешний аккаунт пользователю
 *
 * Удалить данные может администратор
 */
export const unlinkMailuUserIdLinkDelete = <ThrowOnError extends boolean = false>(options: Options<UnlinkMailuUserIdLinkDeleteData, ThrowOnError>) => {
    return (options.client ?? client).delete<UnlinkMailuUserIdLinkDeleteResponses, UnlinkMailuUserIdLinkDeleteErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/mailu/{user_id}/link',
        ...options
    });
};

/**
 *  Get Link
 *
 * Получить данные внешнего аккаунт пользователя
 *
 * Получить данные может администратор или сам пользователь
 */
export const getLinkMailuUserIdLinkGet = <ThrowOnError extends boolean = false>(options: Options<GetLinkMailuUserIdLinkGetData, ThrowOnError>) => {
    return (options.client ?? client).get<GetLinkMailuUserIdLinkGetResponses, GetLinkMailuUserIdLinkGetErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/mailu/{user_id}/link',
        ...options
    });
};

/**
 *  Link
 *
 * Привязать пользователю внешний аккаунт
 *
 * Привязать аккаунт может только администратор
 */
export const linkMailuUserIdLinkPost = <ThrowOnError extends boolean = false>(options: Options<LinkMailuUserIdLinkPostData, ThrowOnError>) => {
    return (options.client ?? client).post<LinkMailuUserIdLinkPostResponses, LinkMailuUserIdLinkPostErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/mailu/{user_id}/link',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 *  Register
 *
 * Создает аккаунт или привязывает существующий
 *
 * Если передана активная сессия пользователя, то привязывает аккаунт Yandex к
 * аккаунту в активной сессии. Иначе, создает новый пользователь и делает Yandex
 * первым методом входа.
 */
export const registerYandexRegistrationPost = <ThrowOnError extends boolean = false>(options: Options<RegisterYandexRegistrationPostData, ThrowOnError>) => {
    return (options.client ?? client).post<RegisterYandexRegistrationPostResponses, RegisterYandexRegistrationPostErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/yandex/registration',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 *  Login
 *
 * Вход в пользователя с помощью аккаунта Yandex
 * Производит вход, если находит пользователя по уникаотному идендификатору. Если аккаунт не
 * найден, возвращает ошибка.
 */
export const loginYandexLoginPost = <ThrowOnError extends boolean = false>(options: Options<LoginYandexLoginPostData, ThrowOnError>) => {
    return (options.client ?? client).post<LoginYandexLoginPostResponses, LoginYandexLoginPostErrors, ThrowOnError>({
        url: '/yandex/login',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 *  Redirect Url
 *
 * URL на который происходит редирект после завершения входа на стороне провайдера
 */
export const redirectUrlYandexRedirectUrlGet = <ThrowOnError extends boolean = false>(options?: Options<RedirectUrlYandexRedirectUrlGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<RedirectUrlYandexRedirectUrlGetResponses, unknown, ThrowOnError>({
        url: '/yandex/redirect_url',
        ...options
    });
};

/**
 *  Auth Url
 *
 * URL на который происходит редирект из приложения для авторизации на стороне провайдера
 */
export const authUrlYandexAuthUrlGet = <ThrowOnError extends boolean = false>(options?: Options<AuthUrlYandexAuthUrlGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<AuthUrlYandexAuthUrlGetResponses, unknown, ThrowOnError>({
        url: '/yandex/auth_url',
        ...options
    });
};

/**
 *  Unregister
 *
 * Отключает для пользователя метод входа
 */
export const unregisterYandexDelete = <ThrowOnError extends boolean = false>(options?: Options<UnregisterYandexDeleteData, ThrowOnError>) => {
    return (options?.client ?? client).delete<UnregisterYandexDeleteResponses, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/yandex',
        ...options
    });
};

/**
 *  Register
 *
 * Создает аккаунт или привязывает существующий
 *
 * Если передана активная сессия пользователя, то привязывает аккаунт Yandex к
 * аккаунту в активной сессии. Иначе, создает новый пользователь и делает Yandex
 * первым методом входа.
 */
export const registerMyMsuRegistrationPost = <ThrowOnError extends boolean = false>(options: Options<RegisterMyMsuRegistrationPostData, ThrowOnError>) => {
    return (options.client ?? client).post<RegisterMyMsuRegistrationPostResponses, RegisterMyMsuRegistrationPostErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/my-msu/registration',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 *  Login
 *
 * Вход в пользователя с помощью аккаунта Yandex
 * Производит вход, если находит пользователя по уникаотному идендификатору. Если аккаунт не
 * найден, возвращает ошибка.
 */
export const loginMyMsuLoginPost = <ThrowOnError extends boolean = false>(options: Options<LoginMyMsuLoginPostData, ThrowOnError>) => {
    return (options.client ?? client).post<LoginMyMsuLoginPostResponses, LoginMyMsuLoginPostErrors, ThrowOnError>({
        url: '/my-msu/login',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 *  Redirect Url
 *
 * URL на который происходит редирект после завершения входа на стороне провайдера
 */
export const redirectUrlMyMsuRedirectUrlGet = <ThrowOnError extends boolean = false>(options?: Options<RedirectUrlMyMsuRedirectUrlGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<RedirectUrlMyMsuRedirectUrlGetResponses, unknown, ThrowOnError>({
        url: '/my-msu/redirect_url',
        ...options
    });
};

/**
 *  Auth Url
 *
 * URL на который происходит редирект из приложения для авторизации на стороне провайдера
 */
export const authUrlMyMsuAuthUrlGet = <ThrowOnError extends boolean = false>(options?: Options<AuthUrlMyMsuAuthUrlGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<AuthUrlMyMsuAuthUrlGetResponses, unknown, ThrowOnError>({
        url: '/my-msu/auth_url',
        ...options
    });
};

/**
 *  Unregister
 *
 * Отключает для пользователя метод входа
 */
export const unregisterMyMsuDelete = <ThrowOnError extends boolean = false>(options?: Options<UnregisterMyMsuDeleteData, ThrowOnError>) => {
    return (options?.client ?? client).delete<UnregisterMyMsuDeleteResponses, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/my-msu',
        ...options
    });
};

/**
 *  Register
 *
 * Создает аккаунт или привязывает существующий
 *
 * Если передана активная сессия пользователя, то привязывает аккаунт Google к аккаунту в
 * активной сессии. иначе, создает новый пользователь и делает Google первым методом входа.
 */
export const registerPhysicsMsuRegistrationPost = <ThrowOnError extends boolean = false>(options: Options<RegisterPhysicsMsuRegistrationPostData, ThrowOnError>) => {
    return (options.client ?? client).post<RegisterPhysicsMsuRegistrationPostResponses, RegisterPhysicsMsuRegistrationPostErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/physics-msu/registration',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 *  Login
 *
 * Вход в пользователя с помощью аккаунта Google
 *
 * Производит вход, если находит пользователя по Google client_id. Если аккаунт не найден,
 * возвращает ошибка.
 */
export const loginPhysicsMsuLoginPost = <ThrowOnError extends boolean = false>(options: Options<LoginPhysicsMsuLoginPostData, ThrowOnError>) => {
    return (options.client ?? client).post<LoginPhysicsMsuLoginPostResponses, LoginPhysicsMsuLoginPostErrors, ThrowOnError>({
        url: '/physics-msu/login',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 *  Redirect Url
 *
 * URL на который происходит редирект после завершения входа на стороне провайдера
 */
export const redirectUrlPhysicsMsuRedirectUrlGet = <ThrowOnError extends boolean = false>(options?: Options<RedirectUrlPhysicsMsuRedirectUrlGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<RedirectUrlPhysicsMsuRedirectUrlGetResponses, unknown, ThrowOnError>({
        url: '/physics-msu/redirect_url',
        ...options
    });
};

/**
 *  Auth Url
 *
 * URL на который происходит редирект из приложения для авторизации на стороне провайдера
 */
export const authUrlPhysicsMsuAuthUrlGet = <ThrowOnError extends boolean = false>(options?: Options<AuthUrlPhysicsMsuAuthUrlGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<AuthUrlPhysicsMsuAuthUrlGetResponses, unknown, ThrowOnError>({
        url: '/physics-msu/auth_url',
        ...options
    });
};

/**
 *  Unregister
 *
 * Отключает для пользователя метод входа
 */
export const unregisterPhysicsMsuDelete = <ThrowOnError extends boolean = false>(options?: Options<UnregisterPhysicsMsuDeleteData, ThrowOnError>) => {
    return (options?.client ?? client).delete<UnregisterPhysicsMsuDeleteResponses, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/physics-msu',
        ...options
    });
};

/**
 *  Unlink
 *
 * Отвязать внешний аккаунт пользователю
 *
 * Удалить данные может администратор
 */
export const unlinkPostgresUserIdLinkDelete = <ThrowOnError extends boolean = false>(options: Options<UnlinkPostgresUserIdLinkDeleteData, ThrowOnError>) => {
    return (options.client ?? client).delete<UnlinkPostgresUserIdLinkDeleteResponses, UnlinkPostgresUserIdLinkDeleteErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/postgres/{user_id}/link',
        ...options
    });
};

/**
 *  Get Link
 *
 * Получить данные внешнего аккаунт пользователя
 *
 * Получить данные может администратор или сам пользователь
 */
export const getLinkPostgresUserIdLinkGet = <ThrowOnError extends boolean = false>(options: Options<GetLinkPostgresUserIdLinkGetData, ThrowOnError>) => {
    return (options.client ?? client).get<GetLinkPostgresUserIdLinkGetResponses, GetLinkPostgresUserIdLinkGetErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/postgres/{user_id}/link',
        ...options
    });
};

/**
 *  Link
 *
 * Привязать пользователю внешний аккаунт
 *
 * Привязать аккаунт может только администратор
 */
export const linkPostgresUserIdLinkPost = <ThrowOnError extends boolean = false>(options: Options<LinkPostgresUserIdLinkPostData, ThrowOnError>) => {
    return (options.client ?? client).post<LinkPostgresUserIdLinkPostResponses, LinkPostgresUserIdLinkPostErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/postgres/{user_id}/link',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 *  Register
 */
export const registerTelegramRegistrationPost = <ThrowOnError extends boolean = false>(options: Options<RegisterTelegramRegistrationPostData, ThrowOnError>) => {
    return (options.client ?? client).post<RegisterTelegramRegistrationPostResponses, RegisterTelegramRegistrationPostErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/telegram/registration',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 *  Login
 *
 * Вход в пользователя с помощью аккаунта https://lk.msu.ru
 *
 * Производит вход, если находит пользователя по уникаотному идендификатору. Если аккаунт не
 * найден, возвращает ошибка.
 */
export const loginTelegramLoginPost = <ThrowOnError extends boolean = false>(options: Options<LoginTelegramLoginPostData, ThrowOnError>) => {
    return (options.client ?? client).post<LoginTelegramLoginPostResponses, LoginTelegramLoginPostErrors, ThrowOnError>({
        url: '/telegram/login',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 *  Redirect Url
 *
 * URL на который происходит редирект после завершения входа на стороне провайдера
 */
export const redirectUrlTelegramRedirectUrlGet = <ThrowOnError extends boolean = false>(options?: Options<RedirectUrlTelegramRedirectUrlGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<RedirectUrlTelegramRedirectUrlGetResponses, unknown, ThrowOnError>({
        url: '/telegram/redirect_url',
        ...options
    });
};

/**
 *  Auth Url
 *
 * URL на который происходит редирект из приложения для авторизации на стороне провайдера
 */
export const authUrlTelegramAuthUrlGet = <ThrowOnError extends boolean = false>(options?: Options<AuthUrlTelegramAuthUrlGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<AuthUrlTelegramAuthUrlGetResponses, unknown, ThrowOnError>({
        url: '/telegram/auth_url',
        ...options
    });
};

/**
 *  Unregister
 *
 * Отключает для пользователя метод входа
 */
export const unregisterTelegramDelete = <ThrowOnError extends boolean = false>(options?: Options<UnregisterTelegramDeleteData, ThrowOnError>) => {
    return (options?.client ?? client).delete<UnregisterTelegramDeleteResponses, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/telegram',
        ...options
    });
};

/**
 *  Register
 *
 * Создает аккаунт или привязывает существующий
 *
 * Если передана активная сессия пользователя, то привязывает аккаунт https://vk.com к
 * аккаунту в активной сессии. Иначе, создает новый пользователь и делает https://vk.com
 * первым методом входа.
 */
export const registerVkRegistrationPost = <ThrowOnError extends boolean = false>(options: Options<RegisterVkRegistrationPostData, ThrowOnError>) => {
    return (options.client ?? client).post<RegisterVkRegistrationPostResponses, RegisterVkRegistrationPostErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/vk/registration',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 *  Login
 *
 * Вход в пользователя с помощью аккаунта https://lk.msu.ru
 *
 * Производит вход, если находит пользователя по уникаотному идендификатору. Если аккаунт не
 * найден, возвращает ошибка.
 */
export const loginVkLoginPost = <ThrowOnError extends boolean = false>(options: Options<LoginVkLoginPostData, ThrowOnError>) => {
    return (options.client ?? client).post<LoginVkLoginPostResponses, LoginVkLoginPostErrors, ThrowOnError>({
        url: '/vk/login',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 *  Redirect Url
 *
 * URL на который происходит редирект после завершения входа на стороне провайдера
 */
export const redirectUrlVkRedirectUrlGet = <ThrowOnError extends boolean = false>(options?: Options<RedirectUrlVkRedirectUrlGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<RedirectUrlVkRedirectUrlGetResponses, unknown, ThrowOnError>({
        url: '/vk/redirect_url',
        ...options
    });
};

/**
 *  Auth Url
 *
 * URL на который происходит редирект из приложения для авторизации на стороне провайдера
 */
export const authUrlVkAuthUrlGet = <ThrowOnError extends boolean = false>(options?: Options<AuthUrlVkAuthUrlGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<AuthUrlVkAuthUrlGetResponses, unknown, ThrowOnError>({
        url: '/vk/auth_url',
        ...options
    });
};

/**
 *  Unregister
 *
 * Отключает для пользователя метод входа
 */
export const unregisterVkDelete = <ThrowOnError extends boolean = false>(options?: Options<UnregisterVkDeleteData, ThrowOnError>) => {
    return (options?.client ?? client).delete<UnregisterVkDeleteResponses, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/vk',
        ...options
    });
};

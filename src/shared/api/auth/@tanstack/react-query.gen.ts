// This file is auto-generated by @hey-api/openapi-ts

import { type DefaultError, queryOptions, type UseMutationOptions } from '@tanstack/react-query';

import { client } from '../client.gen';
import { approveEmailEmailApproveGet, authUrlAuthenticAuthUrlGet, authUrlGithubAuthUrlGet, authUrlGoogleAuthUrlGet, authUrlLkMsuAuthUrlGet, authUrlMyMsuAuthUrlGet, authUrlPhysicsMsuAuthUrlGet, authUrlTelegramAuthUrlGet, authUrlVkAuthUrlGet, authUrlYandexAuthUrlGet, createGroupGroupPost, createScopeScopePost, createSessionSessionPost, deleteGroupGroupIdDelete, deleteScopeScopeIdDelete, deleteSessionSessionTokenDelete, deleteSessionsSessionDelete, deleteUserUserUserIdDelete, getGroupGroupIdGet, getGroupsGroupGet, getLinkAirflowUserIdLinkGet, getLinkCoderUserIdLinkGet, getLinkMailuUserIdLinkGet, getLinkPostgresUserIdLinkGet, getScopeScopeIdGet, getScopesScopeGet, getSessionsSessionGet, getUsersUserGet, getUserUserUserIdGet, jwksOpenidWellKnownJwksGet, linkAirflowUserIdLinkPost, linkCoderUserIdLinkPost, linkMailuUserIdLinkPost, linkPostgresUserIdLinkPost, loginAuthenticLoginPost, loginEmailLoginPost, loginGithubLoginPost, loginGoogleLoginPost, loginLkMsuLoginPost, loginMyMsuLoginPost, loginPhysicsMsuLoginPost, loginTelegramLoginPost, loginVkLoginPost, loginYandexLoginPost, logoutLogoutPost, meMeGet, openidConfigurationOpenidWellKnownOpenidConfigurationGet, type Options, patchGroupGroupIdPatch, patchUserUserUserIdPatch, redirectUrlAuthenticRedirectUrlGet, redirectUrlGithubRedirectUrlGet, redirectUrlGoogleRedirectUrlGet, redirectUrlLkMsuRedirectUrlGet, redirectUrlMyMsuRedirectUrlGet, redirectUrlPhysicsMsuRedirectUrlGet, redirectUrlTelegramRedirectUrlGet, redirectUrlVkRedirectUrlGet, redirectUrlYandexRedirectUrlGet, registerAuthenticRegistrationPost, registerEmailRegistrationPost, registerGithubRegistrationPost, registerGoogleRegistrationPost, registerLkMsuRegistrationPost, registerMyMsuRegistrationPost, registerPhysicsMsuRegistrationPost, registerTelegramRegistrationPost, registerVkRegistrationPost, registerYandexRegistrationPost, requestResetEmailEmailResetEmailRequestPost, requestResetForgottenPasswordEmailResetPasswordRestorePost, requestResetPasswordEmailResetPasswordRequestPost, resetEmailEmailResetEmailGet, resetForgottenPasswordEmailResetPasswordPost, tokenOpenidTokenPost, unlinkAirflowUserIdLinkDelete, unlinkCoderUserIdLinkDelete, unlinkMailuUserIdLinkDelete, unlinkPostgresUserIdLinkDelete, unregisterAuthenticDelete, unregisterGithubDelete, unregisterGoogleDelete, unregisterLkMsuDelete, unregisterMyMsuDelete, unregisterPhysicsMsuDelete, unregisterTelegramDelete, unregisterVkDelete, unregisterYandexDelete, updateScopeScopeIdPatch, updateSessionSessionIdPatch } from '../sdk.gen';
import type { ApproveEmailEmailApproveGetData, AuthUrlAuthenticAuthUrlGetData, AuthUrlGithubAuthUrlGetData, AuthUrlGoogleAuthUrlGetData, AuthUrlLkMsuAuthUrlGetData, AuthUrlMyMsuAuthUrlGetData, AuthUrlPhysicsMsuAuthUrlGetData, AuthUrlTelegramAuthUrlGetData, AuthUrlVkAuthUrlGetData, AuthUrlYandexAuthUrlGetData, CreateGroupGroupPostData, CreateGroupGroupPostError, CreateGroupGroupPostResponse, CreateScopeScopePostData, CreateScopeScopePostError, CreateScopeScopePostResponse, CreateSessionSessionPostData, CreateSessionSessionPostError, CreateSessionSessionPostResponse, DeleteGroupGroupIdDeleteData, DeleteGroupGroupIdDeleteError, DeleteScopeScopeIdDeleteData, DeleteScopeScopeIdDeleteError, DeleteScopeScopeIdDeleteResponse, DeleteSessionSessionTokenDeleteData, DeleteSessionSessionTokenDeleteError, DeleteSessionsSessionDeleteData, DeleteSessionsSessionDeleteError, DeleteUserUserUserIdDeleteData, DeleteUserUserUserIdDeleteError, GetGroupGroupIdGetData, GetGroupsGroupGetData, GetLinkAirflowUserIdLinkGetData, GetLinkCoderUserIdLinkGetData, GetLinkMailuUserIdLinkGetData, GetLinkPostgresUserIdLinkGetData, GetScopeScopeIdGetData, GetScopesScopeGetData, GetSessionsSessionGetData, GetUsersUserGetData, GetUserUserUserIdGetData, JwksOpenidWellKnownJwksGetData, LinkAirflowUserIdLinkPostData, LinkAirflowUserIdLinkPostError, LinkAirflowUserIdLinkPostResponse, LinkCoderUserIdLinkPostData, LinkCoderUserIdLinkPostError, LinkCoderUserIdLinkPostResponse, LinkMailuUserIdLinkPostData, LinkMailuUserIdLinkPostError, LinkMailuUserIdLinkPostResponse, LinkPostgresUserIdLinkPostData, LinkPostgresUserIdLinkPostError, LinkPostgresUserIdLinkPostResponse, LoginAuthenticLoginPostData, LoginAuthenticLoginPostError, LoginAuthenticLoginPostResponse, LoginEmailLoginPostData, LoginEmailLoginPostError, LoginEmailLoginPostResponse, LoginGithubLoginPostData, LoginGithubLoginPostError, LoginGithubLoginPostResponse, LoginGoogleLoginPostData, LoginGoogleLoginPostError, LoginGoogleLoginPostResponse, LoginLkMsuLoginPostData, LoginLkMsuLoginPostError, LoginLkMsuLoginPostResponse, LoginMyMsuLoginPostData, LoginMyMsuLoginPostError, LoginMyMsuLoginPostResponse, LoginPhysicsMsuLoginPostData, LoginPhysicsMsuLoginPostError, LoginPhysicsMsuLoginPostResponse, LoginTelegramLoginPostData, LoginTelegramLoginPostError, LoginTelegramLoginPostResponse, LoginVkLoginPostData, LoginVkLoginPostError, LoginVkLoginPostResponse, LoginYandexLoginPostData, LoginYandexLoginPostError, LoginYandexLoginPostResponse, LogoutLogoutPostData, LogoutLogoutPostResponse, MeMeGetData, OpenidConfigurationOpenidWellKnownOpenidConfigurationGetData, PatchGroupGroupIdPatchData, PatchGroupGroupIdPatchError, PatchGroupGroupIdPatchResponse, PatchUserUserUserIdPatchData, PatchUserUserUserIdPatchError, PatchUserUserUserIdPatchResponse, RedirectUrlAuthenticRedirectUrlGetData, RedirectUrlGithubRedirectUrlGetData, RedirectUrlGoogleRedirectUrlGetData, RedirectUrlLkMsuRedirectUrlGetData, RedirectUrlMyMsuRedirectUrlGetData, RedirectUrlPhysicsMsuRedirectUrlGetData, RedirectUrlTelegramRedirectUrlGetData, RedirectUrlVkRedirectUrlGetData, RedirectUrlYandexRedirectUrlGetData, RegisterAuthenticRegistrationPostData, RegisterAuthenticRegistrationPostError, RegisterAuthenticRegistrationPostResponse, RegisterEmailRegistrationPostData, RegisterEmailRegistrationPostError, RegisterEmailRegistrationPostResponse, RegisterGithubRegistrationPostData, RegisterGithubRegistrationPostError, RegisterGithubRegistrationPostResponse, RegisterGoogleRegistrationPostData, RegisterGoogleRegistrationPostError, RegisterGoogleRegistrationPostResponse, RegisterLkMsuRegistrationPostData, RegisterLkMsuRegistrationPostError, RegisterLkMsuRegistrationPostResponse, RegisterMyMsuRegistrationPostData, RegisterMyMsuRegistrationPostError, RegisterMyMsuRegistrationPostResponse, RegisterPhysicsMsuRegistrationPostData, RegisterPhysicsMsuRegistrationPostError, RegisterPhysicsMsuRegistrationPostResponse, RegisterTelegramRegistrationPostData, RegisterTelegramRegistrationPostError, RegisterTelegramRegistrationPostResponse, RegisterVkRegistrationPostData, RegisterVkRegistrationPostError, RegisterVkRegistrationPostResponse, RegisterYandexRegistrationPostData, RegisterYandexRegistrationPostError, RegisterYandexRegistrationPostResponse, RequestResetEmailEmailResetEmailRequestPostData, RequestResetEmailEmailResetEmailRequestPostError, RequestResetEmailEmailResetEmailRequestPostResponse, RequestResetForgottenPasswordEmailResetPasswordRestorePostData, RequestResetForgottenPasswordEmailResetPasswordRestorePostError, RequestResetForgottenPasswordEmailResetPasswordRestorePostResponse, RequestResetPasswordEmailResetPasswordRequestPostData, RequestResetPasswordEmailResetPasswordRequestPostError, RequestResetPasswordEmailResetPasswordRequestPostResponse, ResetEmailEmailResetEmailGetData, ResetForgottenPasswordEmailResetPasswordPostData, ResetForgottenPasswordEmailResetPasswordPostError, ResetForgottenPasswordEmailResetPasswordPostResponse, TokenOpenidTokenPostData, TokenOpenidTokenPostError, TokenOpenidTokenPostResponse, UnlinkAirflowUserIdLinkDeleteData, UnlinkAirflowUserIdLinkDeleteError, UnlinkCoderUserIdLinkDeleteData, UnlinkCoderUserIdLinkDeleteError, UnlinkMailuUserIdLinkDeleteData, UnlinkMailuUserIdLinkDeleteError, UnlinkPostgresUserIdLinkDeleteData, UnlinkPostgresUserIdLinkDeleteError, UnregisterAuthenticDeleteData, UnregisterGithubDeleteData, UnregisterGoogleDeleteData, UnregisterLkMsuDeleteData, UnregisterMyMsuDeleteData, UnregisterPhysicsMsuDeleteData, UnregisterTelegramDeleteData, UnregisterVkDeleteData, UnregisterYandexDeleteData, UpdateScopeScopeIdPatchData, UpdateScopeScopeIdPatchError, UpdateScopeScopeIdPatchResponse, UpdateSessionSessionIdPatchData, UpdateSessionSessionIdPatchError, UpdateSessionSessionIdPatchResponse } from '../types.gen';

/**
 * Delete Group
 *
 * Scopes: `["auth.scope.delete"]`
 */
export const deleteGroupGroupIdDeleteMutation = (options?: Partial<Options<DeleteGroupGroupIdDeleteData>>): UseMutationOptions<unknown, DeleteGroupGroupIdDeleteError, Options<DeleteGroupGroupIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<unknown, DeleteGroupGroupIdDeleteError, Options<DeleteGroupGroupIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteGroupGroupIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? client).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const getGroupGroupIdGetQueryKey = (options: Options<GetGroupGroupIdGetData>) => createQueryKey('getGroupGroupIdGet', options);

/**
 * Get Group
 *
 * Scopes: `["auth.group.read"]`
 */
export const getGroupGroupIdGetOptions = (options: Options<GetGroupGroupIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getGroupGroupIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getGroupGroupIdGetQueryKey(options)
    });
};

/**
 * Patch Group
 *
 * Scopes: `["auth.group.update"]`
 */
export const patchGroupGroupIdPatchMutation = (options?: Partial<Options<PatchGroupGroupIdPatchData>>): UseMutationOptions<PatchGroupGroupIdPatchResponse, PatchGroupGroupIdPatchError, Options<PatchGroupGroupIdPatchData>> => {
    const mutationOptions: UseMutationOptions<PatchGroupGroupIdPatchResponse, PatchGroupGroupIdPatchError, Options<PatchGroupGroupIdPatchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchGroupGroupIdPatch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getGroupsGroupGetQueryKey = (options?: Options<GetGroupsGroupGetData>) => createQueryKey('getGroupsGroupGet', options);

/**
 * Get Groups
 *
 * Scopes: `["auth.group.read"]`
 */
export const getGroupsGroupGetOptions = (options?: Options<GetGroupsGroupGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getGroupsGroupGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getGroupsGroupGetQueryKey(options)
    });
};

/**
 * Create Group
 *
 * Scopes: `["auth.group.create"]`
 */
export const createGroupGroupPostMutation = (options?: Partial<Options<CreateGroupGroupPostData>>): UseMutationOptions<CreateGroupGroupPostResponse, CreateGroupGroupPostError, Options<CreateGroupGroupPostData>> => {
    const mutationOptions: UseMutationOptions<CreateGroupGroupPostResponse, CreateGroupGroupPostError, Options<CreateGroupGroupPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createGroupGroupPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getScopesScopeGetQueryKey = (options?: Options<GetScopesScopeGetData>) => createQueryKey('getScopesScopeGet', options);

/**
 * Get Scopes
 *
 * Scopes: `["auth.scope.read"]`
 */
export const getScopesScopeGetOptions = (options?: Options<GetScopesScopeGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getScopesScopeGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getScopesScopeGetQueryKey(options)
    });
};

/**
 * Create Scope
 *
 * Scopes: `["auth.scope.create"]`
 */
export const createScopeScopePostMutation = (options?: Partial<Options<CreateScopeScopePostData>>): UseMutationOptions<CreateScopeScopePostResponse, CreateScopeScopePostError, Options<CreateScopeScopePostData>> => {
    const mutationOptions: UseMutationOptions<CreateScopeScopePostResponse, CreateScopeScopePostError, Options<CreateScopeScopePostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createScopeScopePost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Scope
 *
 * Scopes: `["auth.scope.delete"]`
 */
export const deleteScopeScopeIdDeleteMutation = (options?: Partial<Options<DeleteScopeScopeIdDeleteData>>): UseMutationOptions<DeleteScopeScopeIdDeleteResponse, DeleteScopeScopeIdDeleteError, Options<DeleteScopeScopeIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteScopeScopeIdDeleteResponse, DeleteScopeScopeIdDeleteError, Options<DeleteScopeScopeIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteScopeScopeIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getScopeScopeIdGetQueryKey = (options: Options<GetScopeScopeIdGetData>) => createQueryKey('getScopeScopeIdGet', options);

/**
 * Get Scope
 *
 * Scopes: `["auth.scope.read"]`
 */
export const getScopeScopeIdGetOptions = (options: Options<GetScopeScopeIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getScopeScopeIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getScopeScopeIdGetQueryKey(options)
    });
};

/**
 * Update Scope
 *
 * Scopes: `["auth.scope.update"]`
 */
export const updateScopeScopeIdPatchMutation = (options?: Partial<Options<UpdateScopeScopeIdPatchData>>): UseMutationOptions<UpdateScopeScopeIdPatchResponse, UpdateScopeScopeIdPatchError, Options<UpdateScopeScopeIdPatchData>> => {
    const mutationOptions: UseMutationOptions<UpdateScopeScopeIdPatchResponse, UpdateScopeScopeIdPatchError, Options<UpdateScopeScopeIdPatchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateScopeScopeIdPatch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete User
 *
 * Scopes: `["auth.user.delete"]` or `["auth.user.selfdelete"]` for self delete
 */
export const deleteUserUserUserIdDeleteMutation = (options?: Partial<Options<DeleteUserUserUserIdDeleteData>>): UseMutationOptions<unknown, DeleteUserUserUserIdDeleteError, Options<DeleteUserUserUserIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<unknown, DeleteUserUserUserIdDeleteError, Options<DeleteUserUserUserIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteUserUserUserIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUserUserUserIdGetQueryKey = (options: Options<GetUserUserUserIdGetData>) => createQueryKey('getUserUserUserIdGet', options);

/**
 * Get User
 *
 * Scopes: `["auth.user.read"]`
 */
export const getUserUserUserIdGetOptions = (options: Options<GetUserUserUserIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserUserUserIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserUserUserIdGetQueryKey(options)
    });
};

/**
 * Patch User
 *
 * Scopes: `["auth.user.update"]`
 */
export const patchUserUserUserIdPatchMutation = (options?: Partial<Options<PatchUserUserUserIdPatchData>>): UseMutationOptions<PatchUserUserUserIdPatchResponse, PatchUserUserUserIdPatchError, Options<PatchUserUserUserIdPatchData>> => {
    const mutationOptions: UseMutationOptions<PatchUserUserUserIdPatchResponse, PatchUserUserUserIdPatchError, Options<PatchUserUserUserIdPatchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchUserUserUserIdPatch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUsersUserGetQueryKey = (options?: Options<GetUsersUserGetData>) => createQueryKey('getUsersUserGet', options);

/**
 * Get Users
 *
 * Scopes: `["auth.user.read"]`
 */
export const getUsersUserGetOptions = (options?: Options<GetUsersUserGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUsersUserGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUsersUserGetQueryKey(options)
    });
};

/**
 * Logout
 */
export const logoutLogoutPostMutation = (options?: Partial<Options<LogoutLogoutPostData>>): UseMutationOptions<LogoutLogoutPostResponse, DefaultError, Options<LogoutLogoutPostData>> => {
    const mutationOptions: UseMutationOptions<LogoutLogoutPostResponse, DefaultError, Options<LogoutLogoutPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await logoutLogoutPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const meMeGetQueryKey = (options?: Options<MeMeGetData>) => createQueryKey('meMeGet', options);

/**
 * Me
 */
export const meMeGetOptions = (options?: Options<MeMeGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await meMeGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: meMeGetQueryKey(options)
    });
};

/**
 * Delete Sessions
 */
export const deleteSessionsSessionDeleteMutation = (options?: Partial<Options<DeleteSessionsSessionDeleteData>>): UseMutationOptions<unknown, DeleteSessionsSessionDeleteError, Options<DeleteSessionsSessionDeleteData>> => {
    const mutationOptions: UseMutationOptions<unknown, DeleteSessionsSessionDeleteError, Options<DeleteSessionsSessionDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteSessionsSessionDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getSessionsSessionGetQueryKey = (options?: Options<GetSessionsSessionGetData>) => createQueryKey('getSessionsSessionGet', options);

/**
 * Get Sessions
 */
export const getSessionsSessionGetOptions = (options?: Options<GetSessionsSessionGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSessionsSessionGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSessionsSessionGetQueryKey(options)
    });
};

/**
 * Create Session
 */
export const createSessionSessionPostMutation = (options?: Partial<Options<CreateSessionSessionPostData>>): UseMutationOptions<CreateSessionSessionPostResponse, CreateSessionSessionPostError, Options<CreateSessionSessionPostData>> => {
    const mutationOptions: UseMutationOptions<CreateSessionSessionPostResponse, CreateSessionSessionPostError, Options<CreateSessionSessionPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createSessionSessionPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Session
 */
export const deleteSessionSessionTokenDeleteMutation = (options?: Partial<Options<DeleteSessionSessionTokenDeleteData>>): UseMutationOptions<unknown, DeleteSessionSessionTokenDeleteError, Options<DeleteSessionSessionTokenDeleteData>> => {
    const mutationOptions: UseMutationOptions<unknown, DeleteSessionSessionTokenDeleteError, Options<DeleteSessionSessionTokenDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteSessionSessionTokenDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Session
 */
export const updateSessionSessionIdPatchMutation = (options?: Partial<Options<UpdateSessionSessionIdPatchData>>): UseMutationOptions<UpdateSessionSessionIdPatchResponse, UpdateSessionSessionIdPatchError, Options<UpdateSessionSessionIdPatchData>> => {
    const mutationOptions: UseMutationOptions<UpdateSessionSessionIdPatchResponse, UpdateSessionSessionIdPatchError, Options<UpdateSessionSessionIdPatchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateSessionSessionIdPatch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const openidConfigurationOpenidWellKnownOpenidConfigurationGetQueryKey = (options?: Options<OpenidConfigurationOpenidWellKnownOpenidConfigurationGetData>) => createQueryKey('openidConfigurationOpenidWellKnownOpenidConfigurationGet', options);

/**
 * Openid Configuration
 *
 * Конфигурация для подключения OpenID Connect совместимых приложений
 *
 * **Attention:** ручка соответствует спецификации не полностью, не все OIDC приложения смогут ей пользоваться
 */
export const openidConfigurationOpenidWellKnownOpenidConfigurationGetOptions = (options?: Options<OpenidConfigurationOpenidWellKnownOpenidConfigurationGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await openidConfigurationOpenidWellKnownOpenidConfigurationGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: openidConfigurationOpenidWellKnownOpenidConfigurationGetQueryKey(options)
    });
};

export const jwksOpenidWellKnownJwksGetQueryKey = (options?: Options<JwksOpenidWellKnownJwksGetData>) => createQueryKey('jwksOpenidWellKnownJwksGet', options);

/**
 * Jwks
 *
 * Публичные ключи для проверки JWT токенов
 */
export const jwksOpenidWellKnownJwksGetOptions = (options?: Options<JwksOpenidWellKnownJwksGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await jwksOpenidWellKnownJwksGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: jwksOpenidWellKnownJwksGetQueryKey(options)
    });
};

/**
 * Token
 *
 * Ручка для получения токена доступа
 *
 * ## Позволяет
 * - Обменять старый не-JWT токен на новый c таким же набором доступов и таким же сроком давности
 * - Обменять JWT токен на новый, если у него есть SESSION_UPDATE_SCOPE
 *
 * Потенциально будет позволять:
 * - Обменивать Refresh Token на пару Access Token + Refresh Token
 * - Обменивать Code (см. Oauth Authorization Code Flow) на пару Access Token + Refresh Token
 *
 * ## Параметры:
 * Для всех запросов
 * - `grant_type` – refresh_token/client_credentials (см. список в `/.well_known/openid_configuration` в поле `grant_types_supported`)
 * - `client_id` – строка, по которой проверяется принадлежность к проекту (сейчас только app)
 * - `scopes` – список прав для нового токена
 *
 * ### `grant_type=refresh_token`
 * - refresh_token – токен, выданный этой ручкой или ручкой `/login` в методе авторизации
 *
 * ### `grant_type=client_credentials`
 * - `username` – логин пользователя
 * - `password` – пароль пользователя
 */
export const tokenOpenidTokenPostMutation = (options?: Partial<Options<TokenOpenidTokenPostData>>): UseMutationOptions<TokenOpenidTokenPostResponse, TokenOpenidTokenPostError, Options<TokenOpenidTokenPostData>> => {
    const mutationOptions: UseMutationOptions<TokenOpenidTokenPostResponse, TokenOpenidTokenPostError, Options<TokenOpenidTokenPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await tokenOpenidTokenPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 *  Unlink
 *
 * Отвязать внешний аккаунт пользователю
 *
 * Удалить данные может администратор
 */
export const unlinkAirflowUserIdLinkDeleteMutation = (options?: Partial<Options<UnlinkAirflowUserIdLinkDeleteData>>): UseMutationOptions<unknown, UnlinkAirflowUserIdLinkDeleteError, Options<UnlinkAirflowUserIdLinkDeleteData>> => {
    const mutationOptions: UseMutationOptions<unknown, UnlinkAirflowUserIdLinkDeleteError, Options<UnlinkAirflowUserIdLinkDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await unlinkAirflowUserIdLinkDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getLinkAirflowUserIdLinkGetQueryKey = (options: Options<GetLinkAirflowUserIdLinkGetData>) => createQueryKey('getLinkAirflowUserIdLinkGet', options);

/**
 *  Get Link
 *
 * Получить данные внешнего аккаунт пользователя
 *
 * Получить данные может администратор или сам пользователь
 */
export const getLinkAirflowUserIdLinkGetOptions = (options: Options<GetLinkAirflowUserIdLinkGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLinkAirflowUserIdLinkGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLinkAirflowUserIdLinkGetQueryKey(options)
    });
};

/**
 *  Link
 *
 * Привязать пользователю внешний аккаунт
 *
 * Привязать аккаунт может только администратор
 */
export const linkAirflowUserIdLinkPostMutation = (options?: Partial<Options<LinkAirflowUserIdLinkPostData>>): UseMutationOptions<LinkAirflowUserIdLinkPostResponse, LinkAirflowUserIdLinkPostError, Options<LinkAirflowUserIdLinkPostData>> => {
    const mutationOptions: UseMutationOptions<LinkAirflowUserIdLinkPostResponse, LinkAirflowUserIdLinkPostError, Options<LinkAirflowUserIdLinkPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await linkAirflowUserIdLinkPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 *  Register
 *
 * Создает аккаунт или привязывает существующий
 */
export const registerAuthenticRegistrationPostMutation = (options?: Partial<Options<RegisterAuthenticRegistrationPostData>>): UseMutationOptions<RegisterAuthenticRegistrationPostResponse, RegisterAuthenticRegistrationPostError, Options<RegisterAuthenticRegistrationPostData>> => {
    const mutationOptions: UseMutationOptions<RegisterAuthenticRegistrationPostResponse, RegisterAuthenticRegistrationPostError, Options<RegisterAuthenticRegistrationPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await registerAuthenticRegistrationPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 *  Login
 *
 * Вход в пользователя с помощью аккаунта Authentic
 */
export const loginAuthenticLoginPostMutation = (options?: Partial<Options<LoginAuthenticLoginPostData>>): UseMutationOptions<LoginAuthenticLoginPostResponse, LoginAuthenticLoginPostError, Options<LoginAuthenticLoginPostData>> => {
    const mutationOptions: UseMutationOptions<LoginAuthenticLoginPostResponse, LoginAuthenticLoginPostError, Options<LoginAuthenticLoginPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await loginAuthenticLoginPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const redirectUrlAuthenticRedirectUrlGetQueryKey = (options?: Options<RedirectUrlAuthenticRedirectUrlGetData>) => createQueryKey('redirectUrlAuthenticRedirectUrlGet', options);

/**
 *  Redirect Url
 *
 * URL на который происходит редирект после завершения входа на стороне провайдера
 */
export const redirectUrlAuthenticRedirectUrlGetOptions = (options?: Options<RedirectUrlAuthenticRedirectUrlGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await redirectUrlAuthenticRedirectUrlGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: redirectUrlAuthenticRedirectUrlGetQueryKey(options)
    });
};

export const authUrlAuthenticAuthUrlGetQueryKey = (options?: Options<AuthUrlAuthenticAuthUrlGetData>) => createQueryKey('authUrlAuthenticAuthUrlGet', options);

/**
 *  Auth Url
 *
 * URL на который происходит редирект из приложения для авторизации на стороне провайдера
 */
export const authUrlAuthenticAuthUrlGetOptions = (options?: Options<AuthUrlAuthenticAuthUrlGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await authUrlAuthenticAuthUrlGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: authUrlAuthenticAuthUrlGetQueryKey(options)
    });
};

/**
 *  Unregister
 *
 * Отключает для пользователя метод входа
 */
export const unregisterAuthenticDeleteMutation = (options?: Partial<Options<UnregisterAuthenticDeleteData>>): UseMutationOptions<unknown, DefaultError, Options<UnregisterAuthenticDeleteData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<UnregisterAuthenticDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await unregisterAuthenticDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 *  Unlink
 *
 * Отвязать внешний аккаунт пользователю
 *
 * Удалить данные может администратор
 */
export const unlinkCoderUserIdLinkDeleteMutation = (options?: Partial<Options<UnlinkCoderUserIdLinkDeleteData>>): UseMutationOptions<unknown, UnlinkCoderUserIdLinkDeleteError, Options<UnlinkCoderUserIdLinkDeleteData>> => {
    const mutationOptions: UseMutationOptions<unknown, UnlinkCoderUserIdLinkDeleteError, Options<UnlinkCoderUserIdLinkDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await unlinkCoderUserIdLinkDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getLinkCoderUserIdLinkGetQueryKey = (options: Options<GetLinkCoderUserIdLinkGetData>) => createQueryKey('getLinkCoderUserIdLinkGet', options);

/**
 *  Get Link
 *
 * Получить данные внешнего аккаунт пользователя
 *
 * Получить данные может администратор или сам пользователь
 */
export const getLinkCoderUserIdLinkGetOptions = (options: Options<GetLinkCoderUserIdLinkGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLinkCoderUserIdLinkGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLinkCoderUserIdLinkGetQueryKey(options)
    });
};

/**
 *  Link
 *
 * Привязать пользователю внешний аккаунт
 *
 * Привязать аккаунт может только администратор
 */
export const linkCoderUserIdLinkPostMutation = (options?: Partial<Options<LinkCoderUserIdLinkPostData>>): UseMutationOptions<LinkCoderUserIdLinkPostResponse, LinkCoderUserIdLinkPostError, Options<LinkCoderUserIdLinkPostData>> => {
    const mutationOptions: UseMutationOptions<LinkCoderUserIdLinkPostResponse, LinkCoderUserIdLinkPostError, Options<LinkCoderUserIdLinkPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await linkCoderUserIdLinkPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 *  Register
 */
export const registerEmailRegistrationPostMutation = (options?: Partial<Options<RegisterEmailRegistrationPostData>>): UseMutationOptions<RegisterEmailRegistrationPostResponse, RegisterEmailRegistrationPostError, Options<RegisterEmailRegistrationPostData>> => {
    const mutationOptions: UseMutationOptions<RegisterEmailRegistrationPostResponse, RegisterEmailRegistrationPostError, Options<RegisterEmailRegistrationPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await registerEmailRegistrationPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 *  Login
 */
export const loginEmailLoginPostMutation = (options?: Partial<Options<LoginEmailLoginPostData>>): UseMutationOptions<LoginEmailLoginPostResponse, LoginEmailLoginPostError, Options<LoginEmailLoginPostData>> => {
    const mutationOptions: UseMutationOptions<LoginEmailLoginPostResponse, LoginEmailLoginPostError, Options<LoginEmailLoginPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await loginEmailLoginPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const approveEmailEmailApproveGetQueryKey = (options: Options<ApproveEmailEmailApproveGetData>) => createQueryKey('approveEmailEmailApproveGet', options);

/**
 *  Approve Email
 */
export const approveEmailEmailApproveGetOptions = (options: Options<ApproveEmailEmailApproveGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await approveEmailEmailApproveGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: approveEmailEmailApproveGetQueryKey(options)
    });
};

/**
 *  Request Reset Email
 */
export const requestResetEmailEmailResetEmailRequestPostMutation = (options?: Partial<Options<RequestResetEmailEmailResetEmailRequestPostData>>): UseMutationOptions<RequestResetEmailEmailResetEmailRequestPostResponse, RequestResetEmailEmailResetEmailRequestPostError, Options<RequestResetEmailEmailResetEmailRequestPostData>> => {
    const mutationOptions: UseMutationOptions<RequestResetEmailEmailResetEmailRequestPostResponse, RequestResetEmailEmailResetEmailRequestPostError, Options<RequestResetEmailEmailResetEmailRequestPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await requestResetEmailEmailResetEmailRequestPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const resetEmailEmailResetEmailGetQueryKey = (options: Options<ResetEmailEmailResetEmailGetData>) => createQueryKey('resetEmailEmailResetEmailGet', options);

/**
 *  Reset Email
 */
export const resetEmailEmailResetEmailGetOptions = (options: Options<ResetEmailEmailResetEmailGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await resetEmailEmailResetEmailGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: resetEmailEmailResetEmailGetQueryKey(options)
    });
};

/**
 *  Request Reset Password
 */
export const requestResetPasswordEmailResetPasswordRequestPostMutation = (options?: Partial<Options<RequestResetPasswordEmailResetPasswordRequestPostData>>): UseMutationOptions<RequestResetPasswordEmailResetPasswordRequestPostResponse, RequestResetPasswordEmailResetPasswordRequestPostError, Options<RequestResetPasswordEmailResetPasswordRequestPostData>> => {
    const mutationOptions: UseMutationOptions<RequestResetPasswordEmailResetPasswordRequestPostResponse, RequestResetPasswordEmailResetPasswordRequestPostError, Options<RequestResetPasswordEmailResetPasswordRequestPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await requestResetPasswordEmailResetPasswordRequestPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 *  Request Reset Forgotten Password
 */
export const requestResetForgottenPasswordEmailResetPasswordRestorePostMutation = (options?: Partial<Options<RequestResetForgottenPasswordEmailResetPasswordRestorePostData>>): UseMutationOptions<RequestResetForgottenPasswordEmailResetPasswordRestorePostResponse, RequestResetForgottenPasswordEmailResetPasswordRestorePostError, Options<RequestResetForgottenPasswordEmailResetPasswordRestorePostData>> => {
    const mutationOptions: UseMutationOptions<RequestResetForgottenPasswordEmailResetPasswordRestorePostResponse, RequestResetForgottenPasswordEmailResetPasswordRestorePostError, Options<RequestResetForgottenPasswordEmailResetPasswordRestorePostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await requestResetForgottenPasswordEmailResetPasswordRestorePost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 *  Reset Forgotten Password
 */
export const resetForgottenPasswordEmailResetPasswordPostMutation = (options?: Partial<Options<ResetForgottenPasswordEmailResetPasswordPostData>>): UseMutationOptions<ResetForgottenPasswordEmailResetPasswordPostResponse, ResetForgottenPasswordEmailResetPasswordPostError, Options<ResetForgottenPasswordEmailResetPasswordPostData>> => {
    const mutationOptions: UseMutationOptions<ResetForgottenPasswordEmailResetPasswordPostResponse, ResetForgottenPasswordEmailResetPasswordPostError, Options<ResetForgottenPasswordEmailResetPasswordPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await resetForgottenPasswordEmailResetPasswordPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 *  Register
 *
 * Создает аккаунт или привязывает существующий
 *
 * Если передана активная сессия пользователя, то привязывает аккаунт https://github.com к
 * аккаунту в активной сессии. Иначе, создает новый пользователь и делает https://github.com
 * первым методом входа.
 */
export const registerGithubRegistrationPostMutation = (options?: Partial<Options<RegisterGithubRegistrationPostData>>): UseMutationOptions<RegisterGithubRegistrationPostResponse, RegisterGithubRegistrationPostError, Options<RegisterGithubRegistrationPostData>> => {
    const mutationOptions: UseMutationOptions<RegisterGithubRegistrationPostResponse, RegisterGithubRegistrationPostError, Options<RegisterGithubRegistrationPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await registerGithubRegistrationPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 *  Login
 *
 * Вход в пользователя с помощью аккаунта https://github.com
 *
 * Производит вход, если находит пользователя по уникальному идендификатору. Если аккаунт не
 * найден, возвращает ошибка.
 */
export const loginGithubLoginPostMutation = (options?: Partial<Options<LoginGithubLoginPostData>>): UseMutationOptions<LoginGithubLoginPostResponse, LoginGithubLoginPostError, Options<LoginGithubLoginPostData>> => {
    const mutationOptions: UseMutationOptions<LoginGithubLoginPostResponse, LoginGithubLoginPostError, Options<LoginGithubLoginPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await loginGithubLoginPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const redirectUrlGithubRedirectUrlGetQueryKey = (options?: Options<RedirectUrlGithubRedirectUrlGetData>) => createQueryKey('redirectUrlGithubRedirectUrlGet', options);

/**
 *  Redirect Url
 *
 * URL на который происходит редирект после завершения входа на стороне провайдера
 */
export const redirectUrlGithubRedirectUrlGetOptions = (options?: Options<RedirectUrlGithubRedirectUrlGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await redirectUrlGithubRedirectUrlGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: redirectUrlGithubRedirectUrlGetQueryKey(options)
    });
};

export const authUrlGithubAuthUrlGetQueryKey = (options?: Options<AuthUrlGithubAuthUrlGetData>) => createQueryKey('authUrlGithubAuthUrlGet', options);

/**
 *  Auth Url
 *
 * URL на который происходит редирект из приложения для авторизации на стороне провайдера
 */
export const authUrlGithubAuthUrlGetOptions = (options?: Options<AuthUrlGithubAuthUrlGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await authUrlGithubAuthUrlGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: authUrlGithubAuthUrlGetQueryKey(options)
    });
};

/**
 *  Unregister
 *
 * Отключает для пользователя метод входа
 */
export const unregisterGithubDeleteMutation = (options?: Partial<Options<UnregisterGithubDeleteData>>): UseMutationOptions<unknown, DefaultError, Options<UnregisterGithubDeleteData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<UnregisterGithubDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await unregisterGithubDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 *  Register
 *
 * Создает аккаунт или привязывает существующий
 *
 * Если передана активная сессия пользователя, то привязывает аккаунт Google к аккаунту в
 * активной сессии. иначе, создает новый пользователь и делает Google первым методом входа.
 */
export const registerGoogleRegistrationPostMutation = (options?: Partial<Options<RegisterGoogleRegistrationPostData>>): UseMutationOptions<RegisterGoogleRegistrationPostResponse, RegisterGoogleRegistrationPostError, Options<RegisterGoogleRegistrationPostData>> => {
    const mutationOptions: UseMutationOptions<RegisterGoogleRegistrationPostResponse, RegisterGoogleRegistrationPostError, Options<RegisterGoogleRegistrationPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await registerGoogleRegistrationPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 *  Login
 *
 * Вход в пользователя с помощью аккаунта Google
 *
 * Производит вход, если находит пользователя по Google client_id. Если аккаунт не найден,
 * возвращает ошибка.
 */
export const loginGoogleLoginPostMutation = (options?: Partial<Options<LoginGoogleLoginPostData>>): UseMutationOptions<LoginGoogleLoginPostResponse, LoginGoogleLoginPostError, Options<LoginGoogleLoginPostData>> => {
    const mutationOptions: UseMutationOptions<LoginGoogleLoginPostResponse, LoginGoogleLoginPostError, Options<LoginGoogleLoginPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await loginGoogleLoginPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const redirectUrlGoogleRedirectUrlGetQueryKey = (options?: Options<RedirectUrlGoogleRedirectUrlGetData>) => createQueryKey('redirectUrlGoogleRedirectUrlGet', options);

/**
 *  Redirect Url
 *
 * URL на который происходит редирект после завершения входа на стороне провайдера
 */
export const redirectUrlGoogleRedirectUrlGetOptions = (options?: Options<RedirectUrlGoogleRedirectUrlGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await redirectUrlGoogleRedirectUrlGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: redirectUrlGoogleRedirectUrlGetQueryKey(options)
    });
};

export const authUrlGoogleAuthUrlGetQueryKey = (options?: Options<AuthUrlGoogleAuthUrlGetData>) => createQueryKey('authUrlGoogleAuthUrlGet', options);

/**
 *  Auth Url
 *
 * URL на который происходит редирект из приложения для авторизации на стороне провайдера
 */
export const authUrlGoogleAuthUrlGetOptions = (options?: Options<AuthUrlGoogleAuthUrlGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await authUrlGoogleAuthUrlGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: authUrlGoogleAuthUrlGetQueryKey(options)
    });
};

/**
 *  Unregister
 *
 * Отключает для пользователя метод входа
 */
export const unregisterGoogleDeleteMutation = (options?: Partial<Options<UnregisterGoogleDeleteData>>): UseMutationOptions<unknown, DefaultError, Options<UnregisterGoogleDeleteData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<UnregisterGoogleDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await unregisterGoogleDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 *  Register
 *
 * Создает аккаунт или привязывает существующий
 *
 * Если передана активная сессия пользователя, то привязывает аккаунт https://lk.msu.ru к
 * аккаунту в активной сессии. Иначе, создает новый пользователь и делает https://lk.msu.ru
 * первым методом входа.
 */
export const registerLkMsuRegistrationPostMutation = (options?: Partial<Options<RegisterLkMsuRegistrationPostData>>): UseMutationOptions<RegisterLkMsuRegistrationPostResponse, RegisterLkMsuRegistrationPostError, Options<RegisterLkMsuRegistrationPostData>> => {
    const mutationOptions: UseMutationOptions<RegisterLkMsuRegistrationPostResponse, RegisterLkMsuRegistrationPostError, Options<RegisterLkMsuRegistrationPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await registerLkMsuRegistrationPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 *  Login
 *
 * Вход в пользователя с помощью аккаунта https://lk.msu.ru
 *
 * Производит вход, если находит пользователя по уникальному идендификатору. Если аккаунт не
 * найден, возвращает ошибка.
 */
export const loginLkMsuLoginPostMutation = (options?: Partial<Options<LoginLkMsuLoginPostData>>): UseMutationOptions<LoginLkMsuLoginPostResponse, LoginLkMsuLoginPostError, Options<LoginLkMsuLoginPostData>> => {
    const mutationOptions: UseMutationOptions<LoginLkMsuLoginPostResponse, LoginLkMsuLoginPostError, Options<LoginLkMsuLoginPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await loginLkMsuLoginPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const redirectUrlLkMsuRedirectUrlGetQueryKey = (options?: Options<RedirectUrlLkMsuRedirectUrlGetData>) => createQueryKey('redirectUrlLkMsuRedirectUrlGet', options);

/**
 *  Redirect Url
 *
 * URL на который происходит редирект после завершения входа на стороне провайдера
 */
export const redirectUrlLkMsuRedirectUrlGetOptions = (options?: Options<RedirectUrlLkMsuRedirectUrlGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await redirectUrlLkMsuRedirectUrlGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: redirectUrlLkMsuRedirectUrlGetQueryKey(options)
    });
};

export const authUrlLkMsuAuthUrlGetQueryKey = (options?: Options<AuthUrlLkMsuAuthUrlGetData>) => createQueryKey('authUrlLkMsuAuthUrlGet', options);

/**
 *  Auth Url
 *
 * URL на который происходит редирект из приложения для авторизации на стороне провайдера
 */
export const authUrlLkMsuAuthUrlGetOptions = (options?: Options<AuthUrlLkMsuAuthUrlGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await authUrlLkMsuAuthUrlGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: authUrlLkMsuAuthUrlGetQueryKey(options)
    });
};

/**
 *  Unregister
 *
 * Отключает для пользователя метод входа
 */
export const unregisterLkMsuDeleteMutation = (options?: Partial<Options<UnregisterLkMsuDeleteData>>): UseMutationOptions<unknown, DefaultError, Options<UnregisterLkMsuDeleteData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<UnregisterLkMsuDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await unregisterLkMsuDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 *  Unlink
 *
 * Отвязать внешний аккаунт пользователю
 *
 * Удалить данные может администратор
 */
export const unlinkMailuUserIdLinkDeleteMutation = (options?: Partial<Options<UnlinkMailuUserIdLinkDeleteData>>): UseMutationOptions<unknown, UnlinkMailuUserIdLinkDeleteError, Options<UnlinkMailuUserIdLinkDeleteData>> => {
    const mutationOptions: UseMutationOptions<unknown, UnlinkMailuUserIdLinkDeleteError, Options<UnlinkMailuUserIdLinkDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await unlinkMailuUserIdLinkDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getLinkMailuUserIdLinkGetQueryKey = (options: Options<GetLinkMailuUserIdLinkGetData>) => createQueryKey('getLinkMailuUserIdLinkGet', options);

/**
 *  Get Link
 *
 * Получить данные внешнего аккаунт пользователя
 *
 * Получить данные может администратор или сам пользователь
 */
export const getLinkMailuUserIdLinkGetOptions = (options: Options<GetLinkMailuUserIdLinkGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLinkMailuUserIdLinkGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLinkMailuUserIdLinkGetQueryKey(options)
    });
};

/**
 *  Link
 *
 * Привязать пользователю внешний аккаунт
 *
 * Привязать аккаунт может только администратор
 */
export const linkMailuUserIdLinkPostMutation = (options?: Partial<Options<LinkMailuUserIdLinkPostData>>): UseMutationOptions<LinkMailuUserIdLinkPostResponse, LinkMailuUserIdLinkPostError, Options<LinkMailuUserIdLinkPostData>> => {
    const mutationOptions: UseMutationOptions<LinkMailuUserIdLinkPostResponse, LinkMailuUserIdLinkPostError, Options<LinkMailuUserIdLinkPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await linkMailuUserIdLinkPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 *  Register
 *
 * Создает аккаунт или привязывает существующий
 *
 * Если передана активная сессия пользователя, то привязывает аккаунт Yandex к
 * аккаунту в активной сессии. Иначе, создает новый пользователь и делает Yandex
 * первым методом входа.
 */
export const registerYandexRegistrationPostMutation = (options?: Partial<Options<RegisterYandexRegistrationPostData>>): UseMutationOptions<RegisterYandexRegistrationPostResponse, RegisterYandexRegistrationPostError, Options<RegisterYandexRegistrationPostData>> => {
    const mutationOptions: UseMutationOptions<RegisterYandexRegistrationPostResponse, RegisterYandexRegistrationPostError, Options<RegisterYandexRegistrationPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await registerYandexRegistrationPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 *  Login
 *
 * Вход в пользователя с помощью аккаунта Yandex
 * Производит вход, если находит пользователя по уникаотному идендификатору. Если аккаунт не
 * найден, возвращает ошибка.
 */
export const loginYandexLoginPostMutation = (options?: Partial<Options<LoginYandexLoginPostData>>): UseMutationOptions<LoginYandexLoginPostResponse, LoginYandexLoginPostError, Options<LoginYandexLoginPostData>> => {
    const mutationOptions: UseMutationOptions<LoginYandexLoginPostResponse, LoginYandexLoginPostError, Options<LoginYandexLoginPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await loginYandexLoginPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const redirectUrlYandexRedirectUrlGetQueryKey = (options?: Options<RedirectUrlYandexRedirectUrlGetData>) => createQueryKey('redirectUrlYandexRedirectUrlGet', options);

/**
 *  Redirect Url
 *
 * URL на который происходит редирект после завершения входа на стороне провайдера
 */
export const redirectUrlYandexRedirectUrlGetOptions = (options?: Options<RedirectUrlYandexRedirectUrlGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await redirectUrlYandexRedirectUrlGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: redirectUrlYandexRedirectUrlGetQueryKey(options)
    });
};

export const authUrlYandexAuthUrlGetQueryKey = (options?: Options<AuthUrlYandexAuthUrlGetData>) => createQueryKey('authUrlYandexAuthUrlGet', options);

/**
 *  Auth Url
 *
 * URL на который происходит редирект из приложения для авторизации на стороне провайдера
 */
export const authUrlYandexAuthUrlGetOptions = (options?: Options<AuthUrlYandexAuthUrlGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await authUrlYandexAuthUrlGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: authUrlYandexAuthUrlGetQueryKey(options)
    });
};

/**
 *  Unregister
 *
 * Отключает для пользователя метод входа
 */
export const unregisterYandexDeleteMutation = (options?: Partial<Options<UnregisterYandexDeleteData>>): UseMutationOptions<unknown, DefaultError, Options<UnregisterYandexDeleteData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<UnregisterYandexDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await unregisterYandexDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 *  Register
 *
 * Создает аккаунт или привязывает существующий
 *
 * Если передана активная сессия пользователя, то привязывает аккаунт Yandex к
 * аккаунту в активной сессии. Иначе, создает новый пользователь и делает Yandex
 * первым методом входа.
 */
export const registerMyMsuRegistrationPostMutation = (options?: Partial<Options<RegisterMyMsuRegistrationPostData>>): UseMutationOptions<RegisterMyMsuRegistrationPostResponse, RegisterMyMsuRegistrationPostError, Options<RegisterMyMsuRegistrationPostData>> => {
    const mutationOptions: UseMutationOptions<RegisterMyMsuRegistrationPostResponse, RegisterMyMsuRegistrationPostError, Options<RegisterMyMsuRegistrationPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await registerMyMsuRegistrationPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 *  Login
 *
 * Вход в пользователя с помощью аккаунта Yandex
 * Производит вход, если находит пользователя по уникаотному идендификатору. Если аккаунт не
 * найден, возвращает ошибка.
 */
export const loginMyMsuLoginPostMutation = (options?: Partial<Options<LoginMyMsuLoginPostData>>): UseMutationOptions<LoginMyMsuLoginPostResponse, LoginMyMsuLoginPostError, Options<LoginMyMsuLoginPostData>> => {
    const mutationOptions: UseMutationOptions<LoginMyMsuLoginPostResponse, LoginMyMsuLoginPostError, Options<LoginMyMsuLoginPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await loginMyMsuLoginPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const redirectUrlMyMsuRedirectUrlGetQueryKey = (options?: Options<RedirectUrlMyMsuRedirectUrlGetData>) => createQueryKey('redirectUrlMyMsuRedirectUrlGet', options);

/**
 *  Redirect Url
 *
 * URL на который происходит редирект после завершения входа на стороне провайдера
 */
export const redirectUrlMyMsuRedirectUrlGetOptions = (options?: Options<RedirectUrlMyMsuRedirectUrlGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await redirectUrlMyMsuRedirectUrlGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: redirectUrlMyMsuRedirectUrlGetQueryKey(options)
    });
};

export const authUrlMyMsuAuthUrlGetQueryKey = (options?: Options<AuthUrlMyMsuAuthUrlGetData>) => createQueryKey('authUrlMyMsuAuthUrlGet', options);

/**
 *  Auth Url
 *
 * URL на который происходит редирект из приложения для авторизации на стороне провайдера
 */
export const authUrlMyMsuAuthUrlGetOptions = (options?: Options<AuthUrlMyMsuAuthUrlGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await authUrlMyMsuAuthUrlGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: authUrlMyMsuAuthUrlGetQueryKey(options)
    });
};

/**
 *  Unregister
 *
 * Отключает для пользователя метод входа
 */
export const unregisterMyMsuDeleteMutation = (options?: Partial<Options<UnregisterMyMsuDeleteData>>): UseMutationOptions<unknown, DefaultError, Options<UnregisterMyMsuDeleteData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<UnregisterMyMsuDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await unregisterMyMsuDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 *  Register
 *
 * Создает аккаунт или привязывает существующий
 *
 * Если передана активная сессия пользователя, то привязывает аккаунт Google к аккаунту в
 * активной сессии. иначе, создает новый пользователь и делает Google первым методом входа.
 */
export const registerPhysicsMsuRegistrationPostMutation = (options?: Partial<Options<RegisterPhysicsMsuRegistrationPostData>>): UseMutationOptions<RegisterPhysicsMsuRegistrationPostResponse, RegisterPhysicsMsuRegistrationPostError, Options<RegisterPhysicsMsuRegistrationPostData>> => {
    const mutationOptions: UseMutationOptions<RegisterPhysicsMsuRegistrationPostResponse, RegisterPhysicsMsuRegistrationPostError, Options<RegisterPhysicsMsuRegistrationPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await registerPhysicsMsuRegistrationPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 *  Login
 *
 * Вход в пользователя с помощью аккаунта Google
 *
 * Производит вход, если находит пользователя по Google client_id. Если аккаунт не найден,
 * возвращает ошибка.
 */
export const loginPhysicsMsuLoginPostMutation = (options?: Partial<Options<LoginPhysicsMsuLoginPostData>>): UseMutationOptions<LoginPhysicsMsuLoginPostResponse, LoginPhysicsMsuLoginPostError, Options<LoginPhysicsMsuLoginPostData>> => {
    const mutationOptions: UseMutationOptions<LoginPhysicsMsuLoginPostResponse, LoginPhysicsMsuLoginPostError, Options<LoginPhysicsMsuLoginPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await loginPhysicsMsuLoginPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const redirectUrlPhysicsMsuRedirectUrlGetQueryKey = (options?: Options<RedirectUrlPhysicsMsuRedirectUrlGetData>) => createQueryKey('redirectUrlPhysicsMsuRedirectUrlGet', options);

/**
 *  Redirect Url
 *
 * URL на который происходит редирект после завершения входа на стороне провайдера
 */
export const redirectUrlPhysicsMsuRedirectUrlGetOptions = (options?: Options<RedirectUrlPhysicsMsuRedirectUrlGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await redirectUrlPhysicsMsuRedirectUrlGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: redirectUrlPhysicsMsuRedirectUrlGetQueryKey(options)
    });
};

export const authUrlPhysicsMsuAuthUrlGetQueryKey = (options?: Options<AuthUrlPhysicsMsuAuthUrlGetData>) => createQueryKey('authUrlPhysicsMsuAuthUrlGet', options);

/**
 *  Auth Url
 *
 * URL на который происходит редирект из приложения для авторизации на стороне провайдера
 */
export const authUrlPhysicsMsuAuthUrlGetOptions = (options?: Options<AuthUrlPhysicsMsuAuthUrlGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await authUrlPhysicsMsuAuthUrlGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: authUrlPhysicsMsuAuthUrlGetQueryKey(options)
    });
};

/**
 *  Unregister
 *
 * Отключает для пользователя метод входа
 */
export const unregisterPhysicsMsuDeleteMutation = (options?: Partial<Options<UnregisterPhysicsMsuDeleteData>>): UseMutationOptions<unknown, DefaultError, Options<UnregisterPhysicsMsuDeleteData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<UnregisterPhysicsMsuDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await unregisterPhysicsMsuDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 *  Unlink
 *
 * Отвязать внешний аккаунт пользователю
 *
 * Удалить данные может администратор
 */
export const unlinkPostgresUserIdLinkDeleteMutation = (options?: Partial<Options<UnlinkPostgresUserIdLinkDeleteData>>): UseMutationOptions<unknown, UnlinkPostgresUserIdLinkDeleteError, Options<UnlinkPostgresUserIdLinkDeleteData>> => {
    const mutationOptions: UseMutationOptions<unknown, UnlinkPostgresUserIdLinkDeleteError, Options<UnlinkPostgresUserIdLinkDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await unlinkPostgresUserIdLinkDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getLinkPostgresUserIdLinkGetQueryKey = (options: Options<GetLinkPostgresUserIdLinkGetData>) => createQueryKey('getLinkPostgresUserIdLinkGet', options);

/**
 *  Get Link
 *
 * Получить данные внешнего аккаунт пользователя
 *
 * Получить данные может администратор или сам пользователь
 */
export const getLinkPostgresUserIdLinkGetOptions = (options: Options<GetLinkPostgresUserIdLinkGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLinkPostgresUserIdLinkGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLinkPostgresUserIdLinkGetQueryKey(options)
    });
};

/**
 *  Link
 *
 * Привязать пользователю внешний аккаунт
 *
 * Привязать аккаунт может только администратор
 */
export const linkPostgresUserIdLinkPostMutation = (options?: Partial<Options<LinkPostgresUserIdLinkPostData>>): UseMutationOptions<LinkPostgresUserIdLinkPostResponse, LinkPostgresUserIdLinkPostError, Options<LinkPostgresUserIdLinkPostData>> => {
    const mutationOptions: UseMutationOptions<LinkPostgresUserIdLinkPostResponse, LinkPostgresUserIdLinkPostError, Options<LinkPostgresUserIdLinkPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await linkPostgresUserIdLinkPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 *  Register
 */
export const registerTelegramRegistrationPostMutation = (options?: Partial<Options<RegisterTelegramRegistrationPostData>>): UseMutationOptions<RegisterTelegramRegistrationPostResponse, RegisterTelegramRegistrationPostError, Options<RegisterTelegramRegistrationPostData>> => {
    const mutationOptions: UseMutationOptions<RegisterTelegramRegistrationPostResponse, RegisterTelegramRegistrationPostError, Options<RegisterTelegramRegistrationPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await registerTelegramRegistrationPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 *  Login
 *
 * Вход в пользователя с помощью аккаунта https://lk.msu.ru
 *
 * Производит вход, если находит пользователя по уникаотному идендификатору. Если аккаунт не
 * найден, возвращает ошибка.
 */
export const loginTelegramLoginPostMutation = (options?: Partial<Options<LoginTelegramLoginPostData>>): UseMutationOptions<LoginTelegramLoginPostResponse, LoginTelegramLoginPostError, Options<LoginTelegramLoginPostData>> => {
    const mutationOptions: UseMutationOptions<LoginTelegramLoginPostResponse, LoginTelegramLoginPostError, Options<LoginTelegramLoginPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await loginTelegramLoginPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const redirectUrlTelegramRedirectUrlGetQueryKey = (options?: Options<RedirectUrlTelegramRedirectUrlGetData>) => createQueryKey('redirectUrlTelegramRedirectUrlGet', options);

/**
 *  Redirect Url
 *
 * URL на который происходит редирект после завершения входа на стороне провайдера
 */
export const redirectUrlTelegramRedirectUrlGetOptions = (options?: Options<RedirectUrlTelegramRedirectUrlGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await redirectUrlTelegramRedirectUrlGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: redirectUrlTelegramRedirectUrlGetQueryKey(options)
    });
};

export const authUrlTelegramAuthUrlGetQueryKey = (options?: Options<AuthUrlTelegramAuthUrlGetData>) => createQueryKey('authUrlTelegramAuthUrlGet', options);

/**
 *  Auth Url
 *
 * URL на который происходит редирект из приложения для авторизации на стороне провайдера
 */
export const authUrlTelegramAuthUrlGetOptions = (options?: Options<AuthUrlTelegramAuthUrlGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await authUrlTelegramAuthUrlGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: authUrlTelegramAuthUrlGetQueryKey(options)
    });
};

/**
 *  Unregister
 *
 * Отключает для пользователя метод входа
 */
export const unregisterTelegramDeleteMutation = (options?: Partial<Options<UnregisterTelegramDeleteData>>): UseMutationOptions<unknown, DefaultError, Options<UnregisterTelegramDeleteData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<UnregisterTelegramDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await unregisterTelegramDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 *  Register
 *
 * Создает аккаунт или привязывает существующий
 *
 * Если передана активная сессия пользователя, то привязывает аккаунт https://vk.com к
 * аккаунту в активной сессии. Иначе, создает новый пользователь и делает https://vk.com
 * первым методом входа.
 */
export const registerVkRegistrationPostMutation = (options?: Partial<Options<RegisterVkRegistrationPostData>>): UseMutationOptions<RegisterVkRegistrationPostResponse, RegisterVkRegistrationPostError, Options<RegisterVkRegistrationPostData>> => {
    const mutationOptions: UseMutationOptions<RegisterVkRegistrationPostResponse, RegisterVkRegistrationPostError, Options<RegisterVkRegistrationPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await registerVkRegistrationPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 *  Login
 *
 * Вход в пользователя с помощью аккаунта https://lk.msu.ru
 *
 * Производит вход, если находит пользователя по уникаотному идендификатору. Если аккаунт не
 * найден, возвращает ошибка.
 */
export const loginVkLoginPostMutation = (options?: Partial<Options<LoginVkLoginPostData>>): UseMutationOptions<LoginVkLoginPostResponse, LoginVkLoginPostError, Options<LoginVkLoginPostData>> => {
    const mutationOptions: UseMutationOptions<LoginVkLoginPostResponse, LoginVkLoginPostError, Options<LoginVkLoginPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await loginVkLoginPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const redirectUrlVkRedirectUrlGetQueryKey = (options?: Options<RedirectUrlVkRedirectUrlGetData>) => createQueryKey('redirectUrlVkRedirectUrlGet', options);

/**
 *  Redirect Url
 *
 * URL на который происходит редирект после завершения входа на стороне провайдера
 */
export const redirectUrlVkRedirectUrlGetOptions = (options?: Options<RedirectUrlVkRedirectUrlGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await redirectUrlVkRedirectUrlGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: redirectUrlVkRedirectUrlGetQueryKey(options)
    });
};

export const authUrlVkAuthUrlGetQueryKey = (options?: Options<AuthUrlVkAuthUrlGetData>) => createQueryKey('authUrlVkAuthUrlGet', options);

/**
 *  Auth Url
 *
 * URL на который происходит редирект из приложения для авторизации на стороне провайдера
 */
export const authUrlVkAuthUrlGetOptions = (options?: Options<AuthUrlVkAuthUrlGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await authUrlVkAuthUrlGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: authUrlVkAuthUrlGetQueryKey(options)
    });
};

/**
 *  Unregister
 *
 * Отключает для пользователя метод входа
 */
export const unregisterVkDeleteMutation = (options?: Partial<Options<UnregisterVkDeleteData>>): UseMutationOptions<unknown, DefaultError, Options<UnregisterVkDeleteData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<UnregisterVkDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await unregisterVkDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};
